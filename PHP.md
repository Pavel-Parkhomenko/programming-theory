# Answers
- Поскольку PHP - язык с динамической типизацией, то мы можем присваивать одной и той же переменной значения разных типов: 
- PHP является регистрозависимым языком 
- В PHP есть десять базовых типов данных:
  ```
        bool (логический тип) 
        int (целые числа) 
        float (дробные числа) 
        string (строки) 
        array (массивы) 
        object (объекты) 
        callable (функции) 
        mixed (любой тип) 
        resource (ресурсы) 
        null (отсутствие значения)
  ```
- Тип ``iterable``: значение должно представлять массив или класс, который реализует интерфейс Traversable. Применяется при переборе в цикле foreach 
- Так, переменные в двойных кавычках заменяются значениями, а переменные в одинарных кавычках остаются неизменными. 
- Константа null не чувствительна к регистру 
- ``== and === как в javascript ``
- Оператор <=>
```
        0, если оба значения равны (2 == 2) 
        1, если значение слева больше, чем значение справа (3 > 2) 
        –1, если значение слева меньше, чем значение справа (2 < 3)
```
- && - and, || - or, ! - xor. Есть и то и это 
- PHP также поддерживает альтернативный синтаксис для конструкции if..else, при которой вместо открывающей фигурной скобки ставится двоеточие, а в конце всей конструкции ставится ключевое слово endif. 
- switch..case default break 
- match - аналог switch 
- Стоит отметить важное отличие конструкции switch от match: switch сравнивает только значение, но не учитывает тип выражения. Тогда как match также учитывает тип сравниваемого выражения. 
- массивы: ``$numbers = array(1,2,3,4);`` $numbers = []; 
- $numbers = [1=> 1, 2=> 4, 5=> 25, 4=> 16]; - как перечисление 
- foreach($users as $element). Цикл foreach позволяет извлекать не только значения, но и ключи элементов foreach($users as $key => $value) 
- Ассоциативные массивы представляют подвид массивов, в которых, в отличие от обычных массивов, в качестве ключа применяются строки 
- Смешанные массивы. PHP позволяет использовать в одном массиве числовые и строковые индексы 
- функция может вызываться до ее объявления 
- в функция можно устанавливать значение по умолчанию 
- Именнованные параметры позволяют передавать значения параметрам по имени f(age: 23, name: "Bob"); f(name: "Tom", age: 36); 
- rest operator - function sum($name, ...$numbers) 
- Анонимные функции - function exspresion 
- Замыкания в PHP представляют анонимную функцию, которая может использовать переменные из своего локального окружения. В отличие от обычных анонимных функций замыкания в PHP применяют выражение use. $showNumber = function() use($number) { ... } 
- Стрелочные функции (arrow function) позволяют упростить запись анонимных функций, которые возвращают некоторое значение. И при этом стрелочные функции автоматически имеют доступ к переменным из внешнего окружения. $sum = fn($c) => $a + $b + $c; $sum(10) 
- Также стрелочные функции могут применяться в качестве параметров функции 
- ссылки: $sam = &$tom; В данном случае переменной $sam передается не копия значения переменной $tom, как в предыдущем случае, а ссылка на область в памяти, которую занимает переменная $tom. Обе переменных будут указывать на один и тот же адрес в памяти. Это приведет к тому, что изменение значения одной из этих переменных приведет к изменению значения другой переменной. Функция также может возвращать ссылку. В этом случае при определении и вызове функции перед ее именем ставится знак амперсанда: function &checkName(&$name). При вызове функции перед ее именем указывается символ амерсанда!! 
- Блоки циклов и условных конструкций не образуют отдельной области видимости, и переменные, определенные в этих блоках, мы можем использовать вне этих блоков 
- Статические переменные. После завершения работы функции их значение сохраняется. При каждом новом вызове функция использует ранее сохраненное значение
- Изменения пересенной по ссылке
```
        function getCounter() 
        { 
          static $counter = 0; 
          $counter++; 
        } 
        getCounter(); // counter=1 
        getCounter(); // counter=2 
        getCounter(); // counter=3
```
- Глобальные переменные по умолчанию не доступны внутри функции. Тем не менее мы можем обратиться внутри функции к глобальной переменной. Для этого необходимо использовать ключевое слово global: $name = "Tom"; function hello() { global $name; } При чем мы можем не только получать ее значение, но и изменить его. В качестве альтернативы оператору global для обащения к глобальным переменным мы можем использовать встроенный массив $GLOBALS: $username = $GLOBALS["name"]; 
- Оператор const. Для определения константы применяется оператор const, при этом в названии константы знак доллара $ (в отличие от переменных) не используется. Также для определения константы может применяться функция define(), которая имеет следующую форму: 
define(string $name, string $value) 
Встроенные константы: FILE, DIR, FUNCTION, _CLASS, NAMESPACE__ 
- Проверка существования константы 
Чтобы проверить, определена ли константы, мы можем использовать функцию ``bool defined(string $name)``. Если константа $name определена, то функция будет возвращать значение true 
- "Пустая" переменная - это переменная, значение которой равно null, 0, false или пустой строке - в этом случае функция empty() возвращает true 
-  PHP автоматически удаляет переменные, когда завершается выполнение контекста (например, функции), в котором определены эти переменные. 
-  Преобразование типов - ``$boolVar = false; $intVar = (int)$boolVar;`` // 0 
-  Параметры сортировки.
``` 
        SORT_REGULAR: автоматический выбор сортировки 
        SORT_NUMERIC: числовая сортировка 
        SORT_STRING: сортировка по алфавиту
```
- -> оператор доступа к совйствам и методам объекта 
- Сравнение объектов. При сравнении объектов классов следует принимать во внимание ряд особенностей. В частности, при использовании оператора равенства == два объекта считаются равными, если они представляют один и тот же класс и их свойства имеют одинаковые значения. 
А при использовании оператора эквивалентности === оба объекта считаются равными, если обе переменных классах указывают на один и тот же экземпляр класса. 
- Конструктор класса: ``function __construct($name, $age) { ... }.`` Есть параметры по умолчанию 
- Объявление свойств через конструктор. ``function __construct(public $name, public $age) ``
- Деструкторы служат для освобождения ресурсов, используемых программой - для освобождения открытых файлов, открытых подключений к базам данных и т.д. Деструктор объекта вызывается самим интерпретатором PHP после потери последней ссылки на данный объект в программе. function __destruct() { ... } 
- Анонимные классы - это классы, которые не имеют имени. Обычно такие классы полезны, если нам необходимо один раз создать объект подобного класса. И больше этот класс не будет использоваться. $person = new class {}; $person->name = "Pavel" 
- Чтобы наследовать один класс от другого, нам надо применить оператор extends. В PHP мы можем унаследовать класс только от одного класса. 
- parent:: (или Person::) - позволяет нам вызвать метод или конструктор родительского класса. parent::__construct($name); 
- Однако иногда возникают ситуации, когда надо запретить переопределение методов. Для этого в классе-родителе надо указать методы с модификатором final: final function displayInfo() { ... } и в наследнике мы не сможем больше определить этот клас. 
- Если final используется для класса, то мы не сможем наследовать этот класс 
- public, privtae, protected 
- При обращении к статическим методам и свойствам используется имя класса и оператор :: 
- Для обращения к статическим свойствам и методам внутри класса вместо имени класса может применяться ключевое слово self::
- - Стоит отметить, что в статических методах мы можем обращаться только к статическим свойствам и методам. Но не можем обращаться к НЕстатическим свойствам и методам через $this. 
- interface iMessenger {} 
- Для реализации классом интерфейса применяется ключевое слово implements 
- Интерфейсы также могут наследоваться от других интерфейсов 
- Класс может одновременно применять сразу несколько интерфейсов. В этом случае все интерфейсы перечисляются через запятую после слова implements. 
- Traits представляют группу методов, которые могут быть добавлены в классы. trait Printer { }. Для применения классов трейта применяется оператор use, после которого указывается добавляемый трейт 
- оператор <<<, за которым следует метка завершения строки ``($str <<< LABEL Hello, $name LABEL;)``
- Строки можно менять, обращаясь по индексу ``$str[1] = I - Hillo``
- php.ini - тут можно раскомментировать различные пакеты (например mbstring)
- Функция setcookie() может принимать следующие параметры: name, value, expire, path, domain, secure, httponly
- ``$func = fn($a)=> $a``  - стрелочная функция
- С помощью оператора from можно определять массив - источник данных для генератора: ``yield from [2, 3, 4];``
- Однако, абстрактные классы, как и обычные классы, могут иметь переменные, неабстрактные методы, конструкторы с реализацией, а интерфейсы нет. Кроме того, в PHP один класс может наследоваться только от одного класса, тогда как один класс может применять сразу несколько интерфейсов.
- clone - копирование объекта $bob = clone $tom;
- Однако, что если у нас свойство класса представляет другой класс. Чтобы выйти из этой ситуации, необходимо в классе определить метод __clone. Он вызывается при клонировании и может применяться для клонирования вложенных объектов
- Начиная с версии 8.2 PHP позволяет определять классы для чтения. Такой класс определяется с помощью ключевого слова readonly. Свойства таких классов по умолчанию являются свойствами, доступными только для чтения. Это гарантирует, что никакое из свойств объекта не сможет изменить значение. 
- Использование инструкции include имеет недостатки. Так, мы можем в разных местах кода неумышленно подключить один и тот же файл, что при выполнении кода вызовет ошибки.
Чтобы исключить повторное подключение файла, вместо инструкции include следует применять инструкцию include_once
- Действие инструкции require подобно инструкции include: она также подключает внешний файл, вставляя в программу его содержимое. Только теперь, если данный файл не будет найден, действие программы прекратится (инструкция include в этом случае выбрасывает предупреждение):
- cookie - не более 4кб
- Магические методы:
```
     Магический метод __call(), будет перехватывать все попытки вызовов методов, не являющихся публичными. 
    __callStatic()
   __clone()
```
 
---------------------------------------------------------- 
 
COMMANDS 
- print_r - вывести массив с индексами 
- $numbers[] = 25; - добавляет в масиив новое значение 
- count($arr) - Количество элементов массива 
- isset($val) - позволяет определить, инициализирована ли переменная или нет. Если переменная определена, то isset() возвращает значение true. Если переменная не определена, то isset() возвращает false. Также если переменная имеет значение null функция isset() также возвращает false. 
- empty($val) - Функция empty() проверяет переменную на "пустоту". 
- unset($val) - С помощью функции unset() мы можем уничтожить переменную 
- gettype($val) - Для получения типа переменной 
- is_integer, is_string, is_double, is_numeric, is_bool, is_scalar, is_null, is_array, is_object 
- settype("Переменная", "Тип"), settype($a, "integer"); -  можно установить для переменной определенный тип. Если удалось установить тип, то функция возвращает true, если нет - то значение false. 
- is_array($arr) => true or false
- - count/sizeof - эти функции получают количество элементов массива 
- shuffle - Функция shuffle перемешивает элементы массивы случайным образом 
- compact - Функция compact позволяет создать из набора переменных ассоциативный массив, где ключами будут имена переменных. 
- asort($arr) - cортировкa по возрастанию чисел или по алфавиту строк (не учитывает числа и регистр) 
- asort($arr, PARAM) - настраиваемая сортировка 
- arsort() - сортровка в обратном порядке 
- ksort() - сортировка по ключам 
- natsort() - выполняет естественную сортировку (учитывает числа и регистр) 
- natcasesort() - то же, что и natsort, но не учитывает регистр 
- instanceof - оператор, которе позволяет проверить принадлежность объекта определенному класса. $tom instanceof Employee
- strpos($str, $search) возвращает позицию подстроки или символа $search в строке $str или значение false, если строка $str не содержит подстроки $search
- mb_strpos() - как и strpos, но для кириллицы 
- strrpos() во многом аналогична функции strpos(), только ищет позицию не первого, а последнего вхождения подстроки в строку
- trim($str) удаляет из строки начальные и конечные пробелы, а также управляющие символы \n, \r, \t
- Для перевода строки в нижний регистр используется функция strtolower($str). В верхний - strtoupper()/mb_ strtoupper()
- strlen() mb_strlen() возвращает длину строки, то есть количество символов в ней
- substr($str, $start [, $length]), можно получить из одной строки ее определенную часть. Данная функция обрезает строку $str, начиная c символа в позиции $start до конца строки. С помощью дополнительного необязательного параметра $length можно задать количество вырезаемых символов
- Для замены определенной части строки применяется функция str_replace($old, $new, $input). Эта функция заменяет в строке $input все вхождения подстроки $old на подстроку $new с учетом регистра
- htmlentities(). В качестве параметра она принимает значение, которое надо экранировать (при запросе не выполнить js коде, а он будет как строка)
- htmlspecialchars() похожа по действию на htmlentities:
- strip_tags() позволяет полностью исключить теги html:
- mb_convert_case - меняет регистр на противоположный
