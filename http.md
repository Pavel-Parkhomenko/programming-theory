# HTTP

> **HTTP** — это клиент-серверный протокол, то есть запросы отправляются какой-то одной стороной — участником обмена (user-agent)

источник (домен/протокол/порт)

**ЗАПРОС**

    METHOD URL(patch) HTTP/VERSION,
    GET запрошенный URL версия HTTP

**ОТВЕТ**

    protocol status(code) status(text) OK
    
### МЕТОДЫ
- **GET**	Запрашивает представление ресурса. Такие запросы могут только извлекать данные.
- **HEAD**	Запрашивает ресурс, как и GET, но ответ приходит без тела.
- **POST**	Отправляет сущности к указанному ресурсу. Может вызывать побочные эффекты на сервере и изменение состояния.
- **PUT**	Заменяет текущие представления ресурса данными запроса.
- **DELETE**	Удаляет указанный ресурс.
- **CONNECT**	Настраивает туннель с сервером, определенным по ресурсу.
- **OPTIONS**	Описывает параметры соединения с ресурсом. Отличия 
- **TRACE**	Вызывает возвращаемое текстовое сообщение с ресурса.
- **PATCH**	Частично изменяет ресурс.

### PUT vs POST

> Иначе говоря, повторное применение PUT дает тот же результат, что и в первом случае. Повторный вызов POST может давать разные результаты.
> Например, если принимать заказы с помощью POST, то человек может сделать один и тот же заказ несколько раз. Вам следует использовать POST или PUT с учетом того является ли выполняемое действие идемпотентным или нет. (идемпотентный это присваивание, не - инкримент)

Информационные 100 - 199
Успешные 200 - 299
Перенаправления 300 - 399 
Клиентские ошибки 400 - 499
Серверные ошибки 500 - 599

### ЗАГОЛОВКИ

> Заголовки HTTP являются основной частью этих HTTP-запросов и ответов, и они несут информацию о браузере клиента, запрошенной странице, сервере и многом другом.

- Основные заголовки применяется как к запросам, так и к ответам, но не имеет отношения к данным, передаваемым в теле.
- Заголовки запроса содержит больше информации о ресурсе, который нужно получить, или о клиенте, запрашивающем ресурс.
- Заголовки ответа (en-US) содержат дополнительную информацию об ответе, например его местонахождение, или о сервере, предоставившем его.
- Заголовки сущности содержат информацию о теле ресурса, например его длину содержимого или тип MIME.
Value: Name
    Запросы
- HOST - HTTP-запрос отправляется на определенные IP-адреса. Но так как большинство серверов способны размещать несколько сайтов под одним IP, они должны знать, какое доменное имя ищет браузер. (vk.com)
- User-Agent - Имя и версия браузера. Название и версия операционной системы. Язык по умолчанию.
- Accept-Language: en-us,en;q=0.5 - настройка языка по умолчанию
- Accept-Encoding - содержит название алгоритмов сжатия, которые поддерживает клиент. В случае с браузер - то, как он сжал данные (Content-Encoding)
- Cookie
- Authorization - когда на сайте нужна регистрация, то наши данные отправятся в этом заголовке (зашифрованные методом base64)
    Ответы
- Content-Type: text/html; charset=UTF-8 (image/gif)
- Content-Disposition: attachment; filename="download.zip" - говорит браузеру открыть окно загрузки
- Content-Length - размер в байтах
- Set-Cookie - Когда веб-сайт хочет установить или обновить файл cookie в вашем браузере, он будет использовать этот header.
- Location - тут находится адрес для перенаправления пользователя (ошибки 301 302)

### HTTP кэширование
Приватный - для одного пользователя. Браузер сохраняет посещенные страницы для облегчения навигации вперед-назад. Кроме того, кеш полезен при отключении от сети.
Общий - Кеш совместного использования — это кеш, который сохраняет ответы, чтобы их потом могли использовать разные пользователи.

Заголовки:
- Cache-control - используется для задания инструкций по механизму кеширования как в запросах, так и в ответах. (no-cache - можно кэшировать, но нужен Conditional Get, public, private, max-age, must-revalidate - актуальность, no-store - нельзя кэшировать).
- Expires содержит дату/время, по истечении которой ответ сервера считается устаревшим (отправляет сервер)
- Last-Modified
--- вариант 1
Conditional Get (запрос с условием) - сначала проверяем актуальность на сервере, а уж потом загружаем из кэша
браузер посылает запрос, сервет отвечает с заголовком Last-Modified и ресурс записывается в кэш. В след раз, когда браузер будет обращатся к серверу, он установит заголовок if-modified-since с данными из Last-modifield. Сервер может отправить два ответа: status 304 Not Modifield и ресурс поменялся, тоесть отправит новые данные
--- вариант 2
Заголовок
- ETag (entity tag) - содержит некий хэш код, который интетифицирует данные на сервере. Отправляется сервером, а потом клиентом. Если ресурс изменился, то и изменился etag.
В Conditiol Get etag отправляется в If-None-Match

### HTTPS
**HTTPS** — протокол безопасной передачи данных, поддерживает технологию шифрования TLS/SSL.
Чтобы аутентифицировать сервер, браузер посетителя проверяет, подписан ли SSL-сертификат сертификатом доверенного центра.
Чтобы договориться о симметричном ключе шифрования сервер и браузер используют асимметричное шифрование с открытым ключом.
**SSL** - это криптографический протокол, обеспечивающий безопасное общение пользователя и сервера по небезопасной сети (устарел)
SSL-сертификат
**TLS** - гибридного шифрования (симметричное и асиметричное) - RSA (ОК, ЗК), Дэффи-Хелмана (передается остаток от деления)

### CORS (CORS preflight)
Стандарт Cross-Origin Resource Sharing работает с помощью добавления новых HTTP-заголовков
- Origin
CORS безопастный:
Простые запросы: Get, POST, HEAD.
Автоматические заголовки, которые проставляет браузер (User-Agent, Connection - закрыто/открыто и тд).
Свои заголовки
- Accept
- Accept-Language
- Content-Language
- Content-Type
Допустимыми значениями заголовка Content-Type являются:
- application/x-www-form-urlencoded
- multipart/form-data
- text/plain
Сервер ставит следующие заголовки:
- Access-Control-Allow-Origin
При предварительном запросе (OPTIONS):
браузер ставит заголовки:
- Access-Control-Request-Method: POST
- Access-Control-Request-Headers: X-PINGOTHER, Content-Type
Сервер отвечает:
- Access-Control-Allow-Origin: http://foo.example
- Access-Control-Allow-Methods: POST, GET, OPTIONS
- Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
- Access-Control-Max-Age: 86400 - насколько можно закэшировать результат без предварительного запроса

### WEBSOCKET

> Обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение.  Протокол Web Socket определяет две URI-схемы, ws: (нешифрованное соединение) и wss: (шифрованное соединение).

Могут отправлять/получать как строки, так и бинарные данные.
- Заголовки запроса:
Connection: Upgrade – сигнализирует, что клиент хотел бы изменить протокол.
Upgrade: websocket – запрошен протокол «websocket».
Sec-WebSocket-Key – случайный ключ, созданный браузером для обеспечения безопасности.
Sec-WebSocket-Version – версия протокола WebSocket, текущая версия 13.
- Заголовки ответа:
101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g= ключ, Браузер использует его, чтобы убедиться, что ответ соответствует запросу.

### LOCAL and SESSION STORAGE

> Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере. В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе и сервер не может манипулировать ими ключ и значение должны быть строками.

- Методы
setItem(key, value) – сохранить пару ключ/значение.
getItem(key) – получить данные по ключу key.
removeItem(key) – удалить данные с ключом key.
clear() – удалить всё.
key(index) – получить ключ на заданной позиции.
length – количество элементов в хранилище.

### COOKIE
Куки, document.cookie

> Куки – это небольшие строки данных, которые хранятся непосредственно в браузере. Они являются частью HTTP-протокола. Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.

- patch - URL-префикс пути, куки будут доступны для страниц под этим путём.
- domain - Домен определяет, где доступен файл куки.
- expires, max-age - По умолчанию, если куки не имеют ни одного из этих параметров, то они удалятся при закрытии браузера. Такие куки называются сессионными («session cookies»).
expires - Дата истечения срока действия куки, когда браузер удалит его автоматически.
max-age - Альтернатива expires, определяет срок действия куки в секундах с текущего момента.
- secure - Куки следует передавать только по HTTPS-протоколу.
Тоесть куки, установленные сайтом http://site.com, не будут доступны на сайте https://site.com и наоборот.

### JWT
Приложение использует JWT для проверки аутентификации пользователя. (токены короткоживущие, но многоразовые)
JWT — это лишь строка в следующем формате header.payload.signature
- Хедер JWT содержит информацию о том, как должна вычисляться JWT подпись. Хедер — это тоже JSON объект, который выглядит следующим образом:
header = { "alg": "HS256", "typ": "JWT"}
- Payload — это полезные данные, которые хранятся внутри JWT.
payload = { "userId": "b08f86af-35da-48f2-8fab-cef3904660bd" }
- Подпись вычисляется с использование следующего псевдо-кода:
const SECRET_KEY = 'cAtwa1kkEy'
const unsignedToken = base64urlEncode(header) + '.' + base64urlEncode(payload)
const signature = HMAC-SHA256(unsignedToken, SECRET_KEY)
Алгоритм base64url кодирует хедер и payload, созданные на 1 и 2 шаге. Алгоритм соединяет закодированные строки через точку. Затем полученная строка хешируется алгоритмом, заданным в хедере на основе нашего секретного ключа.
После первого логина, клиенту возвращается сгенерированный сервером JWT. При каждом следующем запросе, клиент должен передавать JWT установленным API способом (например, через заголовок или как параметр запроса). Сервер декодирует header и payload и проверяет зарезервированные поля. Если все в порядке, по указанному в header алгоритму составляется подпись. Если полученная подпись совпадает с переданной, пользователя авторизуют.

### REFRESH tocken

> Рефреш токен (RT) — эти токены выполняют только одну специфичную задачу — получение нового токена доступа. Они долгоживущие, но одноразовые.

Основной сценарий использования такой: как только старый JWT истекает, то с ним мы уже не можем получить приватные данные, тогда отправляем RT и нам приходит новая пара JWT+RT. С новым JWT мы снова можем обращаться к приватным ресурсам.

### ПРОКСИ СЕРВЕР

> Прокси-сервер — это дополнительное звено между вами и интернетом. Некий посредник, который отделяет человека от посещаемого сайта.

Может хранить разделяемы кэш
