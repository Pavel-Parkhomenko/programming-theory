# QT / C++ 

## Темы
- strcat
- Указатель на функцию
- #define
- ifdef endif
- тернарник
- ООП
- гетерры сетерры - инкапсуляция
- Конструктор класса
- Непойманные исключения и обработчики catch-all

## ANY INFO
- Каждое ядро процессора способно обрабатывать минимум один поток (основной для приложения), но сейчас ядра делаю многопоточные, а это означает, что одно ядро может одновременно выполнять несколько команд в соответствии с числом ядерных потоков (логических процессоров). Грубо говоря, если в одном ядре 4 ядерных потока, то ядро может выполнить одновременно 4 команды.
- 259 процессов и 3750 потоков? Как? Дело в том, что поток является плодом довольно сложной абстракции. Ядро процессора в каждый такт работы выполняет строго одну операцию, а поддерживать многозадачность удается средствами операционной системы. Это происходит примерно следующим образом: каждое ядро процессора выполняет "кусочек" строго одного потока, затем "замораживает" его, переходя к другому и так далее происходит по циклу.
- Атомарность – это свойство процесса, означающее, что он совершается за один шаг или операцию. Aтомарны только операции, но не типы и не данные. Цель атомарности – обеспечить возможность, чтобы много потоков могли изменять одни и те же данные, и это было потокобезопасно.
- Распараллеливание (или параллелизм) в контексте сортировки означает разделение задачи сортировки на несколько более мелких задач, которые выполняются параллельно на разных процессорных ядрах или потоках.
```#include <execution>
std::sort(std::execution::par, ...);
```

## Функции, методы, свойства

__ STL ``#include <algorithm>``___
- it = min_element(li.begin(), li.end());
- it = max_element(li.begin(), li.end());
- it = find(li.begin(), li.end(), 2); // ищем в списке число 2
- li.insert(it, 7); - вставляем 7 по it
- std::reverse(vect.begin(), vect.end());
- std::sort(vect.begin(), vect.end());

__ String, c-style str __
- sSomething.c_str() конвертация string в c-style
- const char* string::data() const - Возвращает содержимое std::string в виде константной строки C-style.
- sString.append(sTemp, 8, 4); // добавляем к std::string подстроку sTemp. ПЕРЕГРУЗКИ
- string& string::insert(size_type index, const string& str) - вставляет символы/строки, начиная с определенного index std::string. ПЕРЕГРУЗКИ
- strcat(char1[], char2[]] - копирует 2 масив в 1 (добавляет в 1, не изменяет)



## --- Оптимизация ---
- Функции тормозят выполнение программы. Код, написанный «на месте», выполняется значительно быстрее. Можно использовать inline 
- С помощью vec.shrink_to_fit можно освободить память, очистив ёмкость вектора
- vector.at работает медленее чем [ ]
- префиксный оператор (++i) работает быстрее постфиксного (i++)

## --- Вопросы ---
1. Почему не стоит возвращать локальные для функции переменные по адресу или ссылке?
2. Что значит ключевое слово inline?
3. Что такое перегрузка функций?
4. Что такое куча и стек вызовов?
5. Какие итераторы бывают?
6. Как в произвольное место в векторе вставить число?
7. Назовите все контейнеры STL?
8. Чем работа list отличается от vector?
9. Назовите методы контейнеров STL?
10. Чем отличается префисный инкремент от постфиксного?
11. Чем отличается NULL от nullptr?
12. Что такое массив указателей?
13. Что такое указатель? Ссылка?
14. Как создать и очистить двухмерный массив?
15. Как реализовать добавление и удаление в динамической массиве?
16. Как узнать код символа и сам символ?
17. Назовите методы c-style строк?
18. Что такое оператор goto?
19. Почему цикл foreach не работает с динамическим массивами?
20. Что такое int argc и char *argv[] в функции main?
21. Как объединить строки в стиле C?
22. Что такое указатель на функцию?
23. Чем опасно использовать директиву препроцессора define?
24. Когда наиболее лучше всего использовать директивы ifdef и endif?
25. Что такое обработчики cath all?
26. Как объявить лямду? Что такое и как сделать захват переменных? Что такео универсальные лямды? Как передать лямду?
27. Как происходит работа с потоками на примере функции подсчета факториала 3х чисел? (A)
28. Зачем нужен виртуальный деструктор?
29. Как защитить объект от копирования?
30. В чем разница между struct и class?
31. Сколько в памяти занимает произвольная структура?
32. В чем отличие vector от deque?
33. Для чего нужен аллокатор?
34. В чём суть множественного наследования? Какие проблемы могут возникнуть при его использовании? Как их преодолеть?
35. В чем основное различие между деструктором и оператором delete?
36. В чем разница между массивом и списком?

## --- Answers ---
8. Vector каждый раз пересоздается в отличии от list. У list нет прямого доступа к данным, только перебирать
10. При префиксном инкременте сразу возвращается увеличенный элемент, а при постфиксном создаётся промежуточный элемент, который сначала возвращается, а потом увеличивается
11. null это просто макрос для 0, поэтому может возникнуть проблема для проверки на int
12. массив указателей это тот же двухменый массив: ``int **arr = new int* [rows]``
15. Добавление. Сначала создаём новый массив на + 1 элемент, копируем из старого массива в новый, удаляем старый массив, присваиваем ссылку нового массива старому, увеличиваем size. Массив передавать *&arr, &size\
16. код символа просто int, символ char(int)
18. ``Оператор goto`` — это оператор управления потоком выполнения программ, который заставляет центральный процессор выполнить переход из одного участка кода в другой (осуществить прыжок)
19. Для итерации по массиву, цикл foreach должен знать длину массива. Поскольку массивы, которые распадаются в указатель (динамические массивы), не знают своей длины, то циклы foreach с ними работать не могут!
20. Аргументы командной строки. argc - количество аргументов, переданных в программу, argv - место, где хранятся фактические значения аргументов (массив c-style строк)
21. для объединения в стиле с использовать strcat
22. Указатель на функцию это такая переменная, которой мы можем присвоить ссылку на функцию
23. define позволяет определить некоторую константу, например, #define begin {, которая будет заменять все begin на {. Но begin может существоаать в c++, поэтому вызов нативного begin вызовет ошибку
24. Такие директивы оучше всего использовать тошда, когда у на есть какая то отладочная информация (cout что то например), и мы не хотим их удалить или комментить. Мы можем их обернуть в дерективы и управлять, опять выводить или нет. Также есть ещё #else
25. Catch all перехватываюьт все исключения. catch (...) { }
27. (A) Объявляем ``vector<thread> ts.`` Определяем функцию для потока: ``ts.emplace_back([ ] () { fac(num)) }`` - добавляем лямду в вектор потоков. Делаем ``ts[i].join()``
28. Чтобы избежать возможной утечки ресурсов или другого неконтролируемого поведения объекта, в логику работы которого включен вызов деструктора.
29. Сделать private конструктор копирования и оператор =.
30. Практически ни в чем. В struct модификаторы доступа по умолчанию public, в class private. Также отличается и наследование по умолчанию, у struct — public, у class — private.
31. sizeof всех членов + остаток для выравнивания (по умолчанию выравнивание 4 байта) + sizeof указателя на vtable (если есть виртуальные функции) + указатели на классы предков, от которых было сделано виртуальное наследование (размер указателя * количество классов).
32.  у deque (двухстороннюю очередь) есть методы push_front и pop_front. Но основное отличие в организации памяти, у vector она как у обычного Си-массива, т.е. последовательный и непрерывный набор байт, а у deque это фрагменты с разрывами.
33.  Аллокатор это шаблонный класс, который отвечает за выделение памяти и создание объектов. По умолчанию все контейнера используют std::allocator<T>.
34.  Множественное наследование – мощный способ связи классов в с++. С помощью множественного наследования класс может иметь сразу несколько базовых классов, объединяя в себе их свойства. Проблемы, собственно говоря, возникают, когда имеет место такая ситуация:
Пусть класс A – базовый, далее классы B и С наследуют A, к классу D применено множественное наследование - для него базовыми являются одновременно B и C. Программа видит эту структуры таким образом (code). Избежать данной проблемы поможет использование ключевого слова virtual, которое превращает класс A в виртуальный класс, так сказать «класс – шаблон». 
```
  A(1)    A(2)
    |      |
    B      C
     \    /
        D
```
35. Оператор delete освобождает область памяти зарезервированную ранее с помощью оператора new. При этом для объектов автоматически будет вызван деструктор. Деструктор содержит код, который необходимо выполнить до освобождения памяти.
36. Массив – это набор однородных элементов, а список – разнородных.
Распределение памяти массива всегда статическое и непрерывное, а в списке все это динамическое и рандомное.


### --- QT ---
- Заголовочный файл это класс, где объявляются функции. В файле cpp: ``void HeaderFile::function() ``
- Макрос вставляет некий код в то место, где он определен 
```class MyObject : public QObject 
    { 
        Q_OBJECT - макрос 
    };
```
- слот, это функция, которая выполняется при наступлении события (сигнала)
- метод ``connect`` используется для связи сигналов и слотов
- строки ``QString`` можно изменять
- Чтобы навесить событие мыши или клавы, неоьходимо переопределить методы этих событий в классе, для которого мы хотим использовать этим события. Если это стандартные классы (QLabel и тп), то неоьходимо создавать класс на основе этих.
- Если нужно из Второго окна поменять что-то в Первом, то у Второго окна создаем ``signals (void mySignal();)``, а у первого окна создаем слот, который реализует нужную нам логику. В конструкторе Первого окна пишем:
```
TwoForm *twoForm = new TwoForm();
connect(twoForm, &TwoForm::enableButtonClicked_Signal_Two, this, &MainWindow:: onEnableButtonClicked_Slot_Main);
```
Также у Второго окна (при нажитии на кнопку например) вызываем сигнал  ``emit mySignal();``

- Если нужно передать в слот что-то от того, что вызвало сигнал (например текст кнопки), то можно воспользоваться лямдой:
```
QObject::connect(btnRadio2, &QPushButton::clicked, [=]() {
  pushLabelAnsw(btnRadio2->text(), label);
}
// Передаем текст кнопки и QLabel в слот
```

## --- C++ ---
- Правило: Используйте угловые скобки для подключения «системных» заголовочных файлов и двойные кавычки для ваших заголовочных файлов.
- Директиву #define можно использовать для создания макросов. (#define AGE_CONST 21)
- директивы условной компиляции: #ifdef (сокр. от «if defined» = «если определено») позволяет препроцессору проверить, было ли значение ранее определено с помощью директивы #define. Если да, то код между #ifdef и #endif скомпилируется. Если нет, то код будет проигнорирован. Директива #ifndef (сокр. от «if not defined» = «если не определено») — это полная противоположность к #ifdef
- Директивы выполняются перед компиляцией программы: сверху вниз, файл за файлом. Выполняются препроцессором, поэтому неважно где они объявляются 
- Header guards — это директивы условной компиляции. Большинство компиляторов поддерживают более простую, альтернативную форму header guards — директиву #pragma.
- Самый простой способ сообщить компилятору, что определенный идентификатор находится в определенном пространстве имен — использовать оператор разрешения области видимости ::
- Оператор sizeof — это унарный оператор, который вычисляет и возвращает размер определенной переменной или определенного типа данных в байтах.
- Точность зависит от размера типа данных (в типе float точность меньше, чем в типе double) и от присваиваемого значения.
- По умолчанию число с плавающей точкой это double
- Лучшим способом является конвертация переменной из одного типа данных в другой с помощью оператора static_cast.
``static_cast<новый_тип_данных>(выражение)``
- Однако, если в списке инициализаторов меньше, чем может содержать массив, то остальные элементы будут проинициализированы значением 0.
- Заполнить массив нулями: int array[5] = { };
- Чтобы извлечь полную строку из входного потока данных (вместе с пробелами), используйте функцию ``std::getline(). std::cin.ignore(32767, '\n');``
- Ключевое слово typedef позволяет программисту создать псевдоним для любого типа данных и использовать его вместо фактического имени типа. ``typedef double time_t -> time_t age``
- Alias (аналог typedef) - ``using time_t = double;``
- строка C-style - char text[] = "Print this!" (массив чаров)
- Что такое указатель? - это переменная, которая хранит адрес ячейки памяти
- Когда мы оперирует данными, то используем знак *. Когда адресами то &.
- последовательные контейнеры - Vector, list, deque
- Set, multiset, map, multimap
- Итератор это как бы указатель на элемент контейнера, тоесть мы в итератор присваиваем элемент, а потом движемся с помощью it++, тем самым меняя значение итератора. Чтобы взять само значение, делаем *it. const_it, reverse_it
- основные методы итераторов - begin, end, cbegin, cend. Приставка 'c' это const. ВЫЗЫВАЕМ У КОНТЕЙНЕРОВ и присваиваем итератору.
- всякий раз, когда строка перераспределяется, её содержимое получает новый адрес памяти. Это означает, что все текущие ссылки, указатели и итераторы строки становятся недействительными!
- При передаче переменной по ссылке нужно просто объявить параметры функции как ссылки, а не как обычные переменные
- Помните, что фиксированные массивы распадаются в указатели при передаче в функцию, поэтому их длину нужно передавать в виде отдельного параметра.
- Однако, как и при возврате по адресу, вы не должны возвращать локальные переменные по ссылке, тоесть переменные, которые мы создали в мамой функции уничтожаются после отработки функции и ссылка на них становится недействительная
- Ключевое слово inline используется для запроса, чтобы компилятор рассматривал вашу функцию как встроенную. При компиляции вашего кода, все встроенные функции (англ. «inline functions») раскрываются «на месте», то есть вызов функции заменяется копией содержимого самой функции
inline int max() { ... }
- Однако, стоит отметить, что параметры по умолчанию НЕ относятся к параметрам, которые учитываются при определении уникальности функции
- Сегмент кучи (или просто «куча») отслеживает память, используемую для динамического выделения. Подключается когда делаем new
- Не все итераторы поддерживают синтаксис *(it + 2) тоесть сдвиг. Нужно использовать метод advance (it, 2), например, для list
- С помощью vec.insert (it, 100) можно вставить число 100 в место, куда указывает it 
- list - двусвязный список, динамическая структура данных, которая быстро работает с добавлением и удалением
- при работе с итераторами лучше использовать префиксный инкремент/дикремент
- strlen - длина с-style строки. С-style строка заканчивается ноль терминатором (/0)
- Всегда, когда мы выделяем динамически память с помощью new, нужно использовать delete. Но указатель все равно будет указывать на тот адрес, который мы ему выделили, поэтому указателю нужно присвоить nullptr (это делаем после delete!)
- Массив строк с char - ``char *arr[ ] = {"Aaa", "Bbb"}``
- Методы c-style строк (cstring): strcpy(куда, что) или strncpy или strcpy_s, strlen(str), strcat() – добавляет одну строку к другой (опасно);
strncat() – добавляет одну строку к другой (с проверкой длины буфера);
strcmp() – сравнивает две строки (возвращает 0, если они равны);
strncmp() – сравнивает две строки до определенного количества символов (возвращает 0, если равны).
- Обратите внимание на разницу между strlen() и std::size(). strlen() печатает количество символов перед нулевым терминатором, тогда как std::size (или трюк с sizeof()) возвращает размер всего массива, независимо от того, что в нем находится.
- Правило: Используйте обычные ссылки или константные ссылки в качестве объявляемого элемента в цикле foreach (в целях улучшения производительности).
- Цикл foreach не работает с указателями на массив (int arr[ ..]) и динамическими массивами
- эллипсис - double findAverage(int count, ...), va_list, va_start, va_arg
- Адаптеры в с++ - стек, очередь. Почему они адапторы? Потому что внутри себя используют полноценный контейнеры, такие как ``std::vector`` и ``std::deque``, и адаптируют их интерфейс под другой интерфейс (стек - push, pop)

## THREAD
- ``push_back``: Этот метод используется для добавления копии элемента в конец вектора.
- ``emplace_back``: Этот метод используется для добавления элемента в конец вектора, непосредственно конструируя его на месте в векторе. Вместо создания копии, emplace_back вызывает конструктор элемента прямо в памяти вектора. В общем, если у вас есть элемент, который вы хотите добавить в вектор, и вы не хотите создавать дополнительную копию, emplace_back может быть более эффективным выбором.
> ``std::vector<MyStruct> myVector;``
``myVector.emplace_back(42);`` - при добавлении в вектор конструктор MyStruct вызовается автоматически.
Также мы можем передать функцию первым пареметром и аргумент вторым параметром.
vector<thread>.emplace_back(threadFunction, i);
- ``std::thread::join()`` - метод используется для того, чтобы "дождаться" завершения работы потока (выхода из переданной ему функции)
- Класс ``std::atomic`` -  предоставляет атомарные операции для работы с общими данными в многопоточной среде.  Атомарные операции обеспечивают безопасное чтение и запись общих данных, исключая состояния гонки и проблемы, связанные с многопоточностью.
- ``std::thread::detach`` используется для отсоединения потока от объекта std::thread, позволяя потоку работать независимо и завершаться самостоятельно (для фоновых задач)

## LAMDA
``[] (параметры) { действия }`` ()-вызов
Лямды как стрелочные функции можно присваивать переменной
``auto name { [ ] (параметры) {body;} };`` or ``auto name = []() {};``
``[] (int a) { действия }`` (10)-сразу передали параметр.
Указываем возвращаемый тип: ``[](int a, int b) -> double {return a + b;}``.
Лямды можно передавать в другую фукцию. Для этого определим тип парметра: ``int (*func)(int, int)``.
Универсальные лямбда-выражения: ``auto name = [ ] (auto a, auto b) { return a + b };`` or
``template <typename Functor>
void f(Functor functor) { functor(); }``

## Умный указатели unique_ptr
> Oсновная цель использования умных указателей – обеспечить получение ресурса одновременно с инициализацией объекта в одной строке кода. Это нужно для того, чтобы после создания объекта не беспокоится об очищении памяти.

``std::unique_ptr``
``std::shared_ptr``
``std::weak_ptr``

``unique_ptr<MyClass> ptr(new MyClass);`` - объект ptr удалится сам.
МЕТОДЫ
- ``get()`` – возвращает стандартный указатель на объект на основе указателя unique_ptr без передачи прав владения на этот объект. После вызова метода указатель unique_ptr продолжает указывать на тот же объект;
- ``release()`` – возвращает стандартный указатель на основе указателя unique_ptr с передачей прав владения. После вызова метода значение указателя unique_ptr равно nullptr;
- ``reset()`` – сбрасывает право владения на объект. После вызова метода значение указателя unique_ptr равно nullptr.
