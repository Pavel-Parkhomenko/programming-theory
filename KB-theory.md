# QT / C++ 


## ANY INFO
- Каждое ядро процессора способно обрабатывать минимум один поток (основной для приложения), но сейчас ядра делаю многопоточные, а это означает, что одно ядро может одновременно выполнять несколько команд в соответствии с числом ядерных потоков (логических процессоров). Грубо говоря, если в одном ядре 4 ядерных потока, то ядро может выполнить одновременно 4 команды.
- 259 процессов и 3750 потоков? Как? Дело в том, что поток является плодом довольно сложной абстракции. Ядро процессора в каждый такт работы выполняет строго одну операцию, а поддерживать многозадачность удается средствами операционной системы. Это происходит примерно следующим образом: каждое ядро процессора выполняет "кусочек" строго одного потока, затем "замораживает" его, переходя к другому и так далее происходит по циклу.
- Атомарность – это свойство процесса, означающее, что он совершается за один шаг или операцию. Aтомарны только операции, но не типы и не данные. Цель атомарности – обеспечить возможность, чтобы много потоков могли изменять одни и те же данные, и это было потокобезопасно.
- Распараллеливание (или параллелизм) в контексте сортировки означает разделение задачи сортировки на несколько более мелких задач, которые выполняются параллельно на разных процессорных ядрах или потоках.
```
  #include <execution>
  std::sort(std::execution::par, ...);
```
- что такое хеш-функция? Объясните на примере. - это функция, которая преобразует входные данные (называемые ключом или сообщением) в строку фиксированной длины, которая обычно представляет собой числовое значение. Это числовое значение называется хеш-значением или хеш-кодом.
```
void hash_func(string str) { // "Hello"
    int hash_val = 0;

    for(auto &ch: str) {
        hash_val += (int)ch;
    }
    cout << hash_val << endl; // 500
}
```
- АВЛ-дерево (AVL Tree) - это бинарное дерево поиска, которое обладает следующими важными свойствами: cбалансированность.
- Деревья отрезков (Segment Trees) - это структура данных, используемая для эффективного решения задачи нахождения агрегированных (сумма, минимум, максимум и т. д.) значений на отрезках массива. Основная идея состоит в том, чтобы представить массив в виде бинарного дерева, где каждый узел дерева будет представлять некоторый подотрезок массива (сумма от а до б например), а каждый лист это значения массива.

## Функции, методы, свойства

__ STL ``#include <algorithm>``___
```
- it = min_element(li.begin(), li.end());
- it = max_element(li.begin(), li.end());
- it = find(li.begin(), li.end(), 2); // ищем в списке число 2
- binary_search(vec.begin(), vec.end(), 2); // true || false
- li.insert(it, 7); // вставляем 7 по it
- std::reverse(vect.begin(), vect.end());
- std::sort(vect.begin(), vect.end());
- std::count(vec.begin(), vec.end(), 4); // кол-во 4 в vec
- std::min(var1, var2) и std::max(var1, var2)
- int res = std::accumulate(vec.begin(), vec.end(), 0); // сумма вектора
- std::shuffle(vec.begin(), vec.end(), gen); // gen=random, меняет vec
- for_each(vec.begin(), vec.end(), [](int &x) { x = x * 2; }); // увеличиваем каждый элемент в 2 раза
- std::copy(source.begin(), source.end(), std::back_inserter(res)); // коп. из sourse в res
```

__ String, c-style str __
- ``string.c_str()`` конвертация string в c-style
- ``const char* string::data() const`` - Возвращает содержимое std::string в виде константной строки C-style.
- ``string.append(sTemp, 8, 4);`` // добавляем к std::string подстроку sTemp. ПЕРЕГРУЗКИ
- ``string& string::insert(size_type index, const string& str)`` - вставляет символы/строки, начиная с определенного index std::string. ПЕРЕГРУЗКИ
- ``strcat(char1[], char2[])`` - копирует 2 масив в 1 (добавляет в 1, не изменяет)
- ``strlen(string)`` - длина с-style строки. С-style строка заканчивается ноль терминатором (/0)
- Массив строк с char - ``char *arr[ ] = {"Aaa", "Bbb"}``
- ``strcpy(куда, что)`` или strncpy или strcpy_s,
- ``strcat()`` – добавляет одну строку к другой (опасно);
- ``strncat()`` – добавляет одну строку к другой (с проверкой длины буфера);
- ``strcmp()`` – сравнивает две строки (возвращает 0, если они равны);
- ``strncmp()`` – сравнивает две строки до определенного количества символов (возвращает 0, если равны).



## --- Оптимизация ---
- Функции тормозят выполнение программы. Код, написанный «на месте», выполняется значительно быстрее. Можно использовать inline 
- С помощью vec.shrink_to_fit можно освободить память, очистив ёмкость вектора
- vector.at работает медленее чем [ ]
- префиксный оператор (++i) работает быстрее постфиксного (i++)

## --- Вопросы ---
<details>
    <summary>1. Почему не стоит возвращать локальные для функции переменные по адресу или ссылке?</summary>
    ---
</details>
<details>
    <summary>2. Что значит ключевое слово inline?</summary>
    ---
</details>
<details>
    <summary>3. Что такое перегрузка функций?</summary>
    ---
</details>
<details>
  <summary>4. Что такое куча и стек вызовов?</summary><p>
  "Куча" (heap) и "стек вызовов" ``(call stack)`` - это две разные области памяти. Стек вызовов используется для хранения информации о функциях, которые в данный момент вызываются в вашей программе. Куча используется для динамического выделения памяти во время выполнения программы. Это место, где вы можете создавать объекты и структуры данных переменного размера, и они остаются в памяти до явного освобождения.
</p></details>
<details>
    <summary>5. Какие итераторы бывают?</summary>
    ---
</details>

<details>
    <summary>6. Как в произвольное место в векторе вставить число?</summary>
    vec.insert(vec.begin() + 2, 10); // вставляем 10 на позицию 2
</details>

<details>
    <summary>7. Назовите все контейнеры STL?</summary>
    vector, list, deque, array, forward_list, set, map, multiset, multimap, unordered_set, unordered_map, unordered_multiset, unordered_multimap, stack, queue, priority_queue
</details>

<details>
    <summary>8. Чем работа list отличается от vector?</summary>
    Vector каждый раз пересоздается в отличии от list. У list нет прямого доступа к данным, только перебирать.
</details>

<details>
    <summary>9. Назовите методы контейнеров STL?</summary>
    ---
</details>

<details>
    <summary>10. Чем отличается префисный инкремент от постфиксного?</summary>
    При префиксном инкременте сразу возвращается увеличенный элемент, а при постфиксном создаётся промежуточный элемент, который сначала возвращается, а потом увеличивается
</details>

<details>
    <summary>11. Чем отличается NULL от nullptr?</summary>
    null это просто макрос для 0, поэтому может возникнуть проблема для проверки на int
</details>

<details>
    <summary>12. Что такое массив указателей?</summary>
    массив указателей это тот же двухменый массив: ``int **arr = new int* [rows]``
</details>

<details>
    <summary>13. Что такое указатель? Ссылка?</summary>
    ---
</details>

<details>
    <summary>14. Как создать и очистить двухмерный массив?</summary>
    ---
</details>

<details>
    <summary>15. Как реализовать добавление и удаление в динамической массиве?</summary>
    Добавление. Сначала создаём новый массив на + 1 элемент, копируем из старого массива в новый, удаляем старый массив, присваиваем ссылку нового массива старому, увеличиваем size. Массив передавать *&arr, &size\
16. код символа просто int, символ char(int)
</details>

<details>
    <summary>16. Как узнать код символа и сам символ?</summary>
    ---
</details>

<details>
    <summary>17. Назовите методы c-style строк?</summary>
    ---
</details>

<details>
    <summary>18. Что такое оператор goto?</summary>
    ``Оператор goto`` — это оператор управления потоком выполнения программ, который заставляет центральный процессор выполнить переход из одного участка кода в другой (осуществить прыжок)
</details>

<details>
    <summary>19. Почему цикл foreach не работает с динамическим массивами?</summary>
    Для итерации по массиву, цикл foreach должен знать длину массива. Поскольку массивы, которые распадаются в указатель (динамические массивы), не знают своей длины, то циклы foreach с ними работать не могут!
</details>

<details>
    <summary>20. Что такое int argc и char *argv[] в функции main?</summary>
    Аргументы командной строки. argc - количество аргументов, переданных в программу, argv - место, где хранятся фактические значения аргументов (массив c-style строк)
</details>

<details>
    <summary>21. Как объединить строки в стиле C?</summary>
    для объединения в стиле с использовать strcat
</details>

<details>
    <summary>22. Что такое указатель на функцию?</summary>
    Указатель на функцию это такая переменная, которой мы можем присвоить ссылку на функцию
</details>

<details>
    <summary>23. Чем опасно использовать директиву препроцессора define?</summary>
    define позволяет определить некоторую константу, например, #define begin {, которая будет заменять все begin на {. Но begin может существоаать в c++, поэтому вызов нативного begin вызовет ошибку
</details>

<details>
    <summary>24. Когда наиболее лучше всего использовать директивы ifdef и endif?</summary>
    Такие директивы лучше всего использовать тогда, когда у на есть какая то отладочная информация (cout что то например), и мы не хотим их удалить или комментить. Мы можем их обернуть в дерективы и управлять, опять выводить или нет. Также есть ещё #else
</details>

<details>
    <summary>25. Что такое обработчики cath all?</summary>
    Catch all перехватываюет все исключения. catch (...) { }
</details>

<details>
    <summary>26. Как объявить лямду? Что такое и как сделать захват переменных? Что такео универсальные лямды? Как передать лямду?</summary>
    ---
</details>

<details>
    <summary>27. Как происходит работа с потоками на примере функции подсчета факториала 3х чисел? (A)</summary>
    (A) Объявляем ``vector<thread> ts.`` Определяем функцию для потока: ``ts.emplace_back([ ] () { fac(num)) }`` - добавляем лямду в вектор потоков. Делаем ``ts[i].join()``
</details>

<details>
    <summary>28. Зачем нужен виртуальный деструктор?</summary>
    Чтобы избежать возможной утечки ресурсов или другого неконтролируемого поведения объекта, в логику работы которого включен вызов деструктора.
</details>

<details>
    <summary>29. Как защитить объект от копирования?</summary>
    Сделать private конструктор копирования и оператор =.
</details>

<details>
    <summary>30. В чем разница между struct и class?</summary>
    Практически ни в чем. В struct модификаторы доступа по умолчанию public, в class private. Также отличается и наследование по умолчанию, у struct — public, у class — private.
</details>

<details>
    <summary>32. Сколько в памяти занимает произвольная структура?</summary>
    sizeof всех членов + остаток для выравнивания (по умолчанию выравнивание 4 байта) + sizeof указателя на vtable (если есть виртуальные функции) + указатели на классы предков, от которых было сделано виртуальное наследование (размер указателя * количество классов).
</details>

<details>
    <summary>33. В чем отличие vector от deque?</summary>
    у deque (двухстороннюю очередь) есть методы push_front и pop_front. Но основное отличие в организации памяти, у vector она как у обычного Си-массива, т.е. последовательный и непрерывный набор байт, а у deque это фрагменты с разрывами.
</details>

<details>
    <summary>34. Для чего нужен аллокатор?</summary>
    Аллокатор это шаблонный класс, который отвечает за выделение памяти и создание объектов. По умолчанию все контейнера используют std::allocator<T>.
</details>

<details>
    <summary>35. В чём суть множественного наследования? Какие проблемы могут возникнуть при его использовании? Как их преодолеть?</summary>
    Множественное наследование – мощный способ связи классов в с++. С помощью множественного наследования класс может иметь сразу несколько базовых классов, объединяя в себе их свойства. Проблемы, собственно говоря, возникают, когда имеет место такая ситуация:
Пусть класс A – базовый, далее классы B и С наследуют A, к классу D применено множественное наследование - для него базовыми являются одновременно B и C. Программа видит эту структуры таким образом (code). Избежать данной проблемы поможет использование ключевого слова virtual, которое превращает класс A в виртуальный класс, так сказать «класс – шаблон». 
```
  A(1)    A(2)
    |      |
    B      C
     \    /
        D
```
</details>

<details>
    <summary>36. В чем основное различие между деструктором и оператором delete?</summary>
    Оператор delete освобождает область памяти зарезервированную ранее с помощью оператора new. При этом для объектов автоматически будет вызван деструктор. Деструктор содержит код, который необходимо выполнить до освобождения памяти.
</details>

<details>
    <summary>37. В чем разница между массивом и списком?</summary>
    Массив – это набор однородных элементов, а **список** – разнородных.
Распределение памяти массива всегда статическое и непрерывное, а в списке все это динамическое и рандомное.
</details>

<details>
    <summary>38. Что делает функция Friend в C ++?</summary>
    Когда функция или класс объявляются как другие (с использованием **friend**), это означает, что они имеют доступ к приватным и защищенным членам другого класса, как если бы они были методами этого класса. У класса есть private член. Мы вне класса объеявляем функцию, а в классе ее определяем как friend void func(MyClass const MyClass& obj). Теперь данная функция может использовать private члены.
</details>

<details>
    <summary>39. Что такое виртуальные функции?</summary>
    **Виртуальные функции** - это ключевой механизм в объектно-ориентированном программировании (ООП) в C++, который позволяет реализовать полиморфизм.  Она может иметь реализацию по умолчанию или быть чисто виртуальной (абстрактной) функцией без реализации. Виртуальную функцию можно переопределить в производных (дочерних) классах. Это означает, что каждый дочерний класс может предоставить свою собственную реализацию этой функции.
</details>

<details>
    <summary>40. В чем разница между мьютексом и семафором?</summary>
    **Мьютекс (mutex) и семафор (semaphore)** - это два разных механизма синхронизации в многозадачных и многопоточных программах. Оба они могут использоваться для обеспечения безопасного доступа к общим ресурсам. Мьютекс - это средство синхронизации, которое позволяет только одному потоку или процессу одновременно получить доступ к общему ресурсу. Семафор - это средство синхронизации, которое позволяет ограничивать количество потоков, имеющих доступ к общему ресурсу.
</details>

<details>
    <summary>41. Как срабатывают конструкторы и деструкторы при наследовании в с++</summary>
    ```
    A -> B -> C
    C *c = new C();
    delete c;
    // A, B, C, ~C, ~B, ~A
    ```
</details>

<details>
    <summary>42. Что такое string::npos?</summary>
    Это константа в C++, которая используется для обозначения "не найденного" значения при работе со строками. Если равен npos, то не найдено.
</details>

<details>
    <summary>43. Для чего нужен спецификатор final?</summary>
    С помощью спецификатора final мы можем запретить наследование: class Person final {};
</details>

### --- QT ---
- Заголовочный файл это класс, где объявляются функции. В файле cpp: ``void HeaderFile::function() ``
- Макрос вставляет некий код в то место, где он определен 
```class MyObject : public QObject 
    { 
        Q_OBJECT - макрос 
    };
```
- слот, это функция, которая выполняется при наступлении события (сигнала)
- метод ``connect`` используется для связи сигналов и слотов
- строки ``QString`` можно изменять
- Чтобы навесить событие мыши или клавы, неоьходимо переопределить методы этих событий в классе, для которого мы хотим использовать этим события. Если это стандартные классы (QLabel и тп), то неоьходимо создавать класс на основе этих.
- Если нужно из Второго окна поменять что-то в Первом, то у Второго окна создаем ``signals (void mySignal();)``, а у первого окна создаем слот, который реализует нужную нам логику. В конструкторе Первого окна пишем:
```
TwoForm *twoForm = new TwoForm();
connect(twoForm, &TwoForm::enableButtonClicked_Signal_Two, this, &MainWindow:: onEnableButtonClicked_Slot_Main);
```
Также у Второго окна (при нажитии на кнопку например) вызываем сигнал  ``emit mySignal();``

- Если нужно передать в слот что-то от того, что вызвало сигнал (например текст кнопки), то можно воспользоваться лямдой:
```
QObject::connect(btnRadio2, &QPushButton::clicked, [=]() {
  pushLabelAnsw(btnRadio2->text(), label);
}
// Передаем текст кнопки и QLabel в слот
```

## --- C++ ---
- Правило: Используйте угловые скобки для подключения «системных» заголовочных файлов и двойные кавычки для ваших заголовочных файлов.
- Директиву #define можно использовать для создания макросов. (#define AGE_CONST 21)
- директивы условной компиляции: #ifdef (сокр. от «if defined» = «если определено») позволяет препроцессору проверить, было ли значение ранее определено с помощью директивы #define. Если да, то код между #ifdef и #endif скомпилируется. Если нет, то код будет проигнорирован. Директива #ifndef (сокр. от «if not defined» = «если не определено») — это полная противоположность к #ifdef
- Директивы выполняются перед компиляцией программы: сверху вниз, файл за файлом. Выполняются препроцессором, поэтому неважно где они объявляются 
- Header guards — это директивы условной компиляции. Большинство компиляторов поддерживают более простую, альтернативную форму header guards — директиву #pragma.
- Самый простой способ сообщить компилятору, что определенный идентификатор находится в определенном пространстве имен — использовать оператор разрешения области видимости ::
- Оператор sizeof — это унарный оператор, который вычисляет и возвращает размер определенной переменной или определенного типа данных в байтах.
- Точность зависит от размера типа данных (в типе float точность меньше, чем в типе double) и от присваиваемого значения.
- По умолчанию число с плавающей точкой это double
- Лучшим способом является конвертация переменной из одного типа данных в другой с помощью оператора static_cast.
``static_cast<новый_тип_данных>(выражение)``
- Однако, если в списке инициализаторов меньше, чем может содержать массив, то остальные элементы будут проинициализированы значением 0.
- Заполнить массив нулями: int array[5] = { };
- Чтобы извлечь полную строку из входного потока данных (вместе с пробелами), используйте функцию ``std::getline(). std::cin.ignore(32767, '\n');``
- Ключевое слово typedef позволяет программисту создать псевдоним для любого типа данных и использовать его вместо фактического имени типа. ``typedef double time_t -> time_t age``
- Alias (аналог typedef) - ``using time_t = double;``
- строка C-style - char text[] = "Print this!" (массив чаров)
- Что такое указатель? - это переменная, которая хранит адрес ячейки памяти
```
    int a = 10;
    int *aa = &a;
    a++;
    cout << a << endl; // 11
    cout << *aa << endl; // 11
```
- Когда мы оперирует данными, то используем знак *. Когда адресами то &.
- Итератор это как бы указатель на элемент контейнера, тоесть мы в итератор присваиваем элемент, а потом движемся с помощью it++, тем самым меняя значение итератора. Чтобы взять само значение, делаем *it. const_it, reverse_it
- основные методы итераторов - begin, end, cbegin, cend. Приставка 'c' это const. ВЫЗЫВАЕМ У КОНТЕЙНЕРОВ и присваиваем итератору.
- всякий раз, когда строка перераспределяется, её содержимое получает новый адрес памяти. Это означает, что все текущие ссылки, указатели и итераторы строки становятся недействительными (с string всё норм)!
- При передаче переменной по ссылке нужно просто объявить параметры функции как ссылки, а не как обычные переменные
- Помните, что фиксированные массивы распадаются в указатели при передаче в функцию, поэтому их длину нужно передавать в виде отдельного параметра.
- Однако, как и при возврате по адресу, вы не должны возвращать локальные переменные по ссылке, тоесть переменные, которые мы создали в мамой функции уничтожаются после отработки функции и ссылка на них становится недействительная
- Ключевое слово inline используется для запроса, чтобы компилятор рассматривал вашу функцию как встроенную. При компиляции вашего кода, все встроенные функции (англ. «inline functions») раскрываются «на месте», то есть вызов функции заменяется копией содержимого самой функции
inline int max() { ... }
- Однако, стоит отметить, что параметры по умолчанию НЕ относятся к параметрам, которые учитываются при определении уникальности функции
- Не все итераторы поддерживают синтаксис *(it + 2) тоесть сдвиг. Нужно использовать метод advance (it, 2), например, для list
- **list** - двусвязный список, динамическая структура данных, которая быстро работает с добавлением и удалением
- при работе с итераторами лучше использовать префиксный инкремент/дикремент
- Всегда, когда мы выделяем динамически память с помощью new, нужно использовать delete. Но указатель все равно будет указывать на тот адрес, который мы ему выделили, поэтому указателю нужно присвоить nullptr (это делаем после delete!)
- Обратите внимание на разницу между strlen() и std::size(). strlen() печатает количество символов перед нулевым терминатором, тогда как std::size (или трюк с sizeof()) возвращает размер всего массива, независимо от того, что в нем находится.
- Правило: Используйте обычные ссылки или константные ссылки в качестве объявляемого элемента в цикле foreach (в целях улучшения производительности).
- Цикл foreach не работает с указателями на массив (int arr[ ..]) и динамическими массивами
- эллипсис - double findAverage(int count, ...), va_list, va_start, va_arg
- Адаптеры в с++ - стек, очередь. Почему они адапторы? Потому что внутри себя используют полноценный контейнеры, такие как ``std::vector`` и ``std::deque``, и адаптируют их интерфейс под другой интерфейс (стек - push, pop)
- **Абстрактный класс**: должен быть абстрактный метод, нельзя создать объект
- **Ссылка** создается при объявлении и привязывается к существующей переменной. Она является альтернативным именем (псевдонимом) для этой переменной. Ссылка не может иметь нулевого (null) значения. Мы создаем переменную, потом её присваиваем переменной-ссылке (int &aa = a). *аа* содержит тоже значение, что и *а*. При изменении *аа* изменяется и *а*.
```
    int a = 10;
    int &aa = a;
    aa++; // or a++
    cout << a << endl; // 11
    cout << aa << endl; // 11
```
- ***Указатель void\* (указатель на void)***: Указатель void* является универсальным указателем, который не имеет строго определенного типа данных. Он может указывать на адрес любого типа данных, но не предоставляет информацию о типе данных, на который он указывает. Он полезен, когда необходимо передать указатель на функцию или хранить указатель на данные, тип которых не известен в данный момент. Он обеспечивает гибкость, но также требует явного приведения типов для доступа к данным.
```
  int x = 42;
  void* genericPtr = &x; // Указатель на void может указывать на любой тип данных
  int* intPtr = static_cast<int*>(genericPtr); // Приведение указателя void* к int*
  int value = *intPtr; // Получение значения, на которое указывает указатель int*
```


## THREAD
- ``push_back``: Этот метод используется для добавления копии элемента в конец вектора.
- ``emplace_back``: Этот метод используется для добавления элемента в конец вектора, непосредственно конструируя его на месте в векторе. Вместо создания копии, emplace_back вызывает конструктор элемента прямо в памяти вектора. В общем, если у вас есть элемент, который вы хотите добавить в вектор, и вы не хотите создавать дополнительную копию, emplace_back может быть более эффективным выбором.
> ``std::vector<MyStruct> myVector;``
``myVector.emplace_back(42);`` - при добавлении в вектор конструктор MyStruct вызовается автоматически.
Также мы можем передать функцию первым пареметром и аргумент вторым параметром.
vector<thread>.emplace_back(threadFunction, i);
- ``std::thread::join()`` - метод используется для того, чтобы "дождаться" завершения работы потока (выхода из переданной ему функции)
- Класс ``std::atomic`` -  предоставляет атомарные операции для работы с общими данными в многопоточной среде.  Атомарные операции обеспечивают безопасное чтение и запись общих данных, исключая состояния гонки и проблемы, связанные с многопоточностью.
- ``std::thread::detach`` используется для отсоединения потока от объекта std::thread, позволяя потоку работать независимо и завершаться самостоятельно (для фоновых задач)
```
unsigned long long factorial(int n) {
    unsigned long long result = 1;
    for (int i = 2; i <= n; ++i) {
        result *= i;
    }
    return result;
}

int main() {
    std::vector<int> numbers = {5, 7, 10};
    std::vector<std::thread> threads;

    for (int num : numbers) {
        threads.emplace_back([&num] {
            unsigned long long result = factorial(num);
            std::cout << "Factorial of " << num << " is " << result << std::endl;
        });
    }

    for (auto& thread : threads) {
        thread.join();
    }

    return 0;
}
```

## LAMDA
``[] (параметры) { действия }`` ()-вызов
Лямды как стрелочные функции можно присваивать переменной
``auto name { [ ] (параметры) {body;} };`` or ``auto name = []() {};``
``[] (int a) { действия }`` (10)-сразу передали параметр.
Указываем возвращаемый тип: ``[](int a, int b) -> double {return a + b;}``.
Лямды можно передавать в другую фукцию. Для этого определим тип парметра: ``int (*func)(int, int)``.
Универсальные лямбда-выражения: ``auto name = [ ] (auto a, auto b) { return a + b };`` or
``template <typename Functor>
void f(Functor functor) { functor(); }``

## Умный указатели unique_ptr
> Oсновная цель использования умных указателей – обеспечить получение ресурса одновременно с инициализацией объекта в одной строке кода. Это нужно для того, чтобы после создания объекта не беспокоится об очищении памяти.

``std::unique_ptr``
``std::shared_ptr``
``std::weak_ptr``

``unique_ptr<MyClass> ptr(new MyClass);`` - объект ptr удалится сам.
МЕТОДЫ
- ``get()`` – возвращает стандартный указатель на объект на основе указателя unique_ptr без передачи прав владения на этот объект. После вызова метода указатель unique_ptr продолжает указывать на тот же объект;
- ``release()`` – возвращает стандартный указатель на основе указателя unique_ptr с передачей прав владения. После вызова метода значение указателя unique_ptr равно nullptr;
- ``reset()`` – сбрасывает право владения на объект. После вызова метода значение указателя unique_ptr равно nullptr.

## Контейнеры в с++
-- Контейнеры последовательности (Sequence Containers):
- **std::vector:** Динамический массив.
- **std::list:** Связанный список.
- **std::deque:** Двусторонняя очередь.
- **std::array:** Статический массив фиксированного размера (C++11 и новее).

-- Ассоциативные контейнеры (Associative Containers):
- **std::set:** Множество уникальных элементов, упорядоченных по возрастанию.
- **std::multiset:** Множество элементов, позволяющее дубликаты, упорядоченных по возрастанию.
- **std::map:** Ассоциативный массив (словарь) с уникальными ключами.
- **std::multimap:** Ассоциативный массив с возможностью дублирования ключей.

-- Контейнеры ассоциативных массивов (Unordered Associative Containers):
- **std::unordered_set:** Неупорядоченное множество уникальных элементов с хешированием.
- **std::unordered_multiset:** Неупорядоченное множество элементов с хешированием, позволяющее дубликаты.
- **std::unordered_map:** Неупорядоченный ассоциативный массив с хешированием ключей.
- **std::unordered_multimap:** Неупорядоченный ассоциативный массив с хешированием ключей, позволяющий дублирование ключей.

-- Адаптеры контейнеров (Container Adapters):
- **std::stack:** Адаптер для реализации стека (последним вошел - первым вышел).
- **std::queue:** Адаптер для реализации очереди (первым вошел - первым вышел).
- **std::priority_queue:** Адаптер для реализации приоритетной очереди.

-- Другие контейнеры:
- **std::bitset:** Контейнер для работы с битами (булевыми значениями).
- **std::valarray:** Контейнер для работы с массивами чисел (C++11 и новее).
