### React Reconciliation
Current tree
Work and Progress tree
New type - - New tree
Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты. Обновляя style, React также знает, что нужно обновлять только изменившиеся свойства.
**Сверка** — это алгоритм React, используемый для того, чтобы отличить одно дерево елементов от другого для определения частей, которые нужно будет заменить.
**React Fiber** — прогрессивная реализация ключевого алгоритма React. Цель Fiber в увеличении производительности при разработке таких задач как анимация, организация элементов на странице и движение элементов. Ее главная особенность это инкрементный рендеринг: способность разделять работу рендера на единицы и распределять их между множественными фреймами.

### Принципы
- DRY - не повторяй это - принцип, который говорит, что не нужно писать один и тот же код несколько раз, если его можен вынести и переиспользовать
- KISS - сохрани краткость и простоту - не используй библиотеку, если тебе надо лишь малая ее часть. Не показывай обычному юзеру то, чем он вряд ли будет пользоваться каждый день (можно спрятать в выпадающее меню). Не стремись к большой точности (ты же не в Nasa работаешь)
- YAGNI - тебе это не понадобится - принцип, который говорит, что не нужно делать больше, чем это требуется. Нужно придерживатся технического задания и не пытаться сделать и предусмотреть все и сразу (тебе за это не заплатят)

### Теория
- Сборка (или «бандлинг») — это процесс выявления импортированных файлов и объединения их в один «собранный» файл (часто называемый «bundle» или «бандл»)
- React.lazy принимает функцию, которая должна вызвать динамический `import()`. Результатом возвращённого Promise является модуль, который экспортирует по умолчанию React-компонент (export default).
- Используем `ReactDOM.hydrate()` вместо `ReactDOM.render()`, если рендерим статическую разметку, полученную от сервера.
- React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.
- Сам факт возврата null из метода render компонента никак не влияет на срабатывание методов жизненного цикла компонента. Например, componentDidUpdate будет всё равно вызван.
- Импорт SVG как компонент: `import { ReactComponent as Logo } from './logo.svg'`
- Для предотвращения повторного рендеринга из setState() достаточно вернуть null.
- Объект **state** описывает внутреннее состояние компонента, он похож на props за тем исключением, что состояние определяется внутри компонента и доступно только из компонента.
- При обращении к this в JSX-колбэках необходимо учитывать, что методы класса в JavaScript по умолчанию не привязаны к контексту. 
- **JSX** — синтаксический сахар для функции React.createElement(component, props, ...children)
- Однако в случае с использованием стрелочной функции есть вероятность столкнуться с проблемой производительности, если функция обработчика передается через свойства props вложенным компонентам 
- **setState**`(func(prevState, prevProps) => return {counter: prevState.counter + 1})`
- **Да, так как setState работает asynchronous**. Это означает, что после вызова setState переменная this.state не изменяется немедленно. так что если вы хотите выполнить действие сразу после установки состояния для переменной состояния и затем вернуть результат, обратный вызов будет полезен
`setState({ }, () => {} )`
SyntheticEvent. Все события в реакт всплывают, мы не можем вернуть false, нужно вызывать event.preventDefault для предотвращения работы по умолчанию. 
Чтобы зарегистрировать событие на фазе перехвата (capture), просто добавьте Capture к имени события; например, вместо onClick используйте onClickCapture
- **this.forceUpdate(callback)** - По умолчанию при изменении состояния компонента или пропсов, происходит повторный рендер. Если ваш метод render() зависит от некоторых других данных, вы можете указать React необходимость в повторном рендере, вызвав forceUpdate(). пропускает shouldComponentUpdate()
- **defaultProps** - можно определить как свойство самого класса компонента, которое позволяет установить пропсы класса по умолчанию. Это используется для неопределённых (undefined) пропсов, но не для пропсов со значением null
- иммутабельность данных. Проще говоря, не изменяйте то, что есть, а создавайте новое на основе старого.
- **Подъем состояния.** Для любых изменяемых данных в React-приложении должен быть один «источник истины». Часто несколько компонентов должны отражать одни и те же изменяющиеся данные. Мы рекомендуем поднимать общее состояние до ближайшего общего предка. Однонаправленность! 
- **Композиция** - props.children. Иногда мы рассматриваем компоненты как «частные случаи» других компонентов. Например, мы можем полагать, что WelcomeDialog является частным случаем Dialog.
- **Фрагменты** - React.Fragment, <></>, typeof=react.element, type=react.fragment. key — это единственный атрибут, допустимый у Fragment
- **компонент высшего порядка** — это функция, которая принимает компонент и возвращает новый компонент. Компонент высшего порядка в React это паттерн, используемый для того, чтобы делить функционал между компонентами без повторения кода. Такие компоненты, по факту, не совсем являются компонентами, это скорее функции. Такая функция берёт компонент как аргумент и отдаёт уже готовый компонент. Она переделывает заданный компонент в другой компонент и добавляет дополнительные данные, либо фунционал. (27.04). Функция-обертка принимает компонент, внутри себя создает новый классовый компонент, в рендере возвращаем переданный компонент, а в пропсы передаем добавленный функционал.
- **Sideeffect** (console.log и тп) - это что-то, что может повлиять на "чистоту" вашей функции. Чистая функция, это значит такая, что если ей на вход подать одни и те же параметры, то результат будет всегда один и тот же.
- `**export const MyContext** = React.createContext(defaultValue: any)`
`<MyContext.Provider value=any>, <MyContext.Consumer> { (value) => {.....} }</>`
Не используйте Context, если он заменяет пробрасывание всего на один-два уровня. Этот инструмент — отличный способ, если нужно распространить состояние на множество компонентов.
В свойство класса contextType может быть назначен объект контекста, созданный с помощью `React.createContext()`. Он нужен для того, чтобы мы могли использовать контекст не  только в render (ни как MyContext.Provider), но и в теле класса (cost value = this.context). 
useContext аналогичен contextType
const value = useContext(MyContext)
Изменение контекста приводит к ре-рендеринг
-  **componentDidCatch**`(error, errorInfo)` вызывается после метода рендеринга, который отображает резервный пользовательский интерфейс, и это может привести к дополнительным проблемам, в то время как `getDerivedStateFromError(error)` (state меняем здесь) обновляет состояние до фазы рендеринга, так что отображается правильный резервный пользовательский интерфейс.
предохранители отлавливают ошибки исключительно в своих дочерних компонентах
`unstable_handleError = componentDidCatch`
Начиная с React 16, ошибки, не отловленные ни одним из предохранителей, будут приводить к размонтированию всего дерева компонентов React.
errorInfo содержит componentStack - здесь мы можем увидеть тот компонент, который сгенерировал ошибку
- **Порталы** позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента. `ReactDOM.createPortal(child, container)`
`import * as ReactDOM from 'react-dom'`
-  **рендер-проп** — функция, которая возвращает другую функцию и является пропсом в другом компоненте. Она сообщает компоненту что необходимо рендерить. Любой проп, который используется компонентом и является функцией рендеринга, технически является и «рендер-пропом». Для переиспользования компоненты, мы передаем в качестве пропса функцию, которая возвращает то, что нужно отрендерить.
Нужна, чтобы вынести общую логику! Альтернатива HOC.

```
<Comp> - этот компонент как бы обобщает то, что должно следовать одной логике
    <CommonComp render={param => <LittleComp1 prop={param}/>}
    <CommonComp render={param => <LittleComp2 prop={param}/>}
    <CommonComp render={param => <LittleComp3 prop={param}/>}
</Comp>
```

`CommonComp: render ( return { this.props.render(this.state) } ) ` - вся логика в CommonComp
render - обычный пропс, который хранит функцию, потом мы вызываем эту функцию и передаем туда параметры
Все тоже самое можно сделать с помощью children
React Router, Downshift и Formik.
- Нельзя использовать **ref** атрибут с функциональными компонентами, потому что для них не создаётся экземпляров. (экземпляр let user = new User)
- в myRef.current также можно сохранить что-то, что мы хотим, чтобы оно не изменилось(таймер для последующего сброса и тп) 
При назначении ref классовой компоненте, мы получаем его экземпляр, тоесть можем получить его свойства и методы (в том числе state) 
Фокус, анимация, интеграция с дом библиотеками
`this.myRef = React.createRef(); `
`const myRef = useRef(null) `
`Callback ref` через конструктор 
Свойсво `current`
React присвоит свойству current элемент DOM, когда компонент будет монтирован, и значение null, когда компонент будет демонтирован.                 
Обновления ref происходят перед срабатыванием методов ЖЦ `componentDidMount` или `componentDidUpdate`.
Если вы хотите запустить некоторый код, когда React присоединяет или отсоединяет реф к узлу DOM, вы можете использовать колбэк-реф вместо этого.
    *useRef* — это хук, использующий одну и ту же ссылку. Он сохраняет свое значение между повторными отрисовками в функциональном компоненте и не создает новый экземпляр ссылки для каждого повторного рендеринга.
    *createRef* — это функция, которая каждый раз создает новую ссылку. В отличие от useRef, он не сохраняет свое значение между повторными отрисовками, а создает новый экземпляр ссылки для каждого повторного рендеринга.
Перенаправление рефов позволяет автоматически передавать реф компонента одному из его дочерних элементов. 
- **React.forwardRef((props, ref)** нужен для того, что мы могли получить элемент из дочерней компоненты (аналогично c экземпляром в классовой компоненте) (из компоненты FancyButton вытащить button и использовать его в Menu)
Так же можно пробрасывать ref как пропс, только нужно использовать другое имя, например, `inputRef={ref}`

### HOOKS
React 16.8.0 это первый релиз, поддерживающий хуки.
Большинство хуков работают асинхронно (в отличиние от методов ЖЦ)
- Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.
- Что такое хук? Хук — это специальная функция, которая позволяет «подцепиться» к возможностям React.

Правило хуков: 
1. Используйте хуки только на верхнем уровне
Не вызывайте хуки внутри циклов, условных операторов или вложенных функций.
2. Вызывайте хуки только из React-функций
Не вызывайте хуки из обычных функций JavaScript. Вместо этого можно:
 - Вызывать хуки из функционального компонента React.
 - Вызывать хуки из пользовательского хука


> Итак, как же React сопоставляет переменные состояния с вызовами useState? Ответ таков: React полагается на порядок вызова хуков. Наш пример работает, потому что порядок вызова хуков одинаков при каждомрендере.  
> .... вот почему хуки должны вызываться на верхнем уровне компонента. Если мы хотим запускать эффект по условию, то можем поместить это условие внутрь хука.

Пока не существует хуков, реализующих методы жизненного цикла `**getSnapshotBeforeUpdate, getDerivedStateFromError и componentDidCatch**`

### useState
- Вызов useState вернёт пару значений: текущее состояние и функцию, обновляющую состояние.
- в отличие от this.setState в классах, обновление переменной состояния всегда замещает её значение, а не осуществляет слияние.
- В отличие от метода setState, useState не объединяет объекты обновления автоматически. (нужно использовать spred оператор)
- Если вы обновите состояние хука тем же значением, что и текущее состояние, React досрочно выйдет из хука без повторного рендера дочерних элементов и запуска эффектов. (React использует алгоритм сравнения Object.is.)
- если в useState передать callback, то - Если начальное состояние является результатом дорогостоящих вычислений, вы можете вместо этого предоставить функцию, которая будет выполняться только при начальном рендеринге

### useEffect
React откладывает выполнение `useEffect`, пока браузер не отрисует все изменения, поэтому выполнение дополнительной работы не является существенной проблемой. (отличия от ЖЦ)
.... каждое значение, на которое ссылается функция эффекта, должно также появиться в массиве зависимостей. 
Without [ ]
- Существует два распространённых вида побочных эффектов в компонентах React: компоненты, которые требуют и не требуют сброса. Сетевые запросы, изменения DOM вручную, логирование — всё это примеры эффектов, которые не требуют сброса. (запустили их и пусть работают)
- Что же делает useEffect? Используя этот хук, вы говорите React сделать что-то после рендера. React запомнит функцию (то есть «эффект»), которую вы передали и вызовет её после того, как внесёт все изменения в DOM.
-  эффект запустится только после того, как DOM уже обновился.
-  функция, которую мы передаём в useEffect, будет меняться при каждом рендере. На самом деле, это было сделано преднамеренно. Это как раз то, что даёт нам возможность получать актуальную версию переменной count изнутри эффекта
-  useLayoutEffect - синхронный useEffect
-  этап сброса эффекта происходит после каждого последующего рендера, а не один лишь раз во время размонтирования. Он (useEffect) сбрасывает предыдущие эффекты прежде чем выполнить новые.
-  С помощью хуков, мы можем разделить наш код основываясь на том, что он делает, а не по принципам методов жизненного цикла. React будет выполнять каждый используемый эффект в компоненте, согласно порядку их объявления.
[...]
- React будет пропускать вызов эффекта, если значение в скобках не изменилось
[  ]
- Если вы хотите запустить эффект и сбросить его только один раз (при монтировании и размонтировании), вы можете передать пустой массив ([ ]) вторым аргументом.

### useMemo 
Возвращает мемоизированное значение.
Принимает «создающую» функцию и массив зависимостей. useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере. 
функция, переданная useMemo, запускается во время рендеринга, поэтому там не стоит делать какие-то эффекты. Если нет массива зависимостей, то срабатывает при каждом рендеринге

### useCallback
Возвращает мемоизированный колбэк.
Передайте встроенный колбэк и массив зависимостей. Хук useCallback вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей.  
`useCallback(fn, deps) — это эквивалент useMemo(() => fn, deps).`
использование useCallback выгодно только в случае передачи функции как props

### useRef
Единственная разница между useRef() и просто созданием самого объекта {current: ...} — это то, что хук useRef даст один и тот же объект с рефом при каждом рендере. 

### useImperativeHandle(ref, callback => {...} )
настраивает значение экземпляра, которое предоставляется родительским компонентам при использовании ref. `useImperativeHandle` должен использоваться с `forwardRef`.
Мы обозначаем объект со свойсвами, методами, которые будут доступны, когда родительский компонент будет получать элемент с помощью ref, тоесть указываем что будет хранится по ссылке (референсу)

### useLayoutEffect
Используйте его для чтения макета из DOM и синхронного повторного рендеринга. Обычно используют для того, чтобы что-то посчитать до первого рендеринга, например, вычислить размеры чего-нибудь, и для того, чтобы не происходил эффект мерцания, когда мы что-то отрисовали, потом посчитали размеры, и перерисовали

### useReducer
Данный хук является альтернативой хуку useState и применяется в случаях, когда первоначальный стейт является более сложным и когда новое состояние зависит от предыдущего. 
Принимает три параметра: функция редьюсер(state, action) (там наш свитч с cases - inc, dec, reset), initialState, и функция для инитициализации начального состояния (позволяет вынести логику получения этого состояния, а не хранить ее в useReducer)
`const [state, dispatch] = useReducer(reducer, initState)`
`dispatch({ type: 'inc', payload: 1 })`

### useDebugValue (info: string, callback)
используется для того, чтобы в DevTools React видеть некоторые значения, которые нам как разработчикам будет удобнее воспринимать при дебаге пользовательского хука (только в custom hook). В DevTools видны только сколько состояний, эффектов (так и подписаны - State, Callback, Effect, Ref).
Callback нужен для того, что если значение info слишком дорогостоещее чтобы вычислять каждый раз, то мы может передать callback и он будет вызывать только при просмотре в DevTools.

### customHooks
Создание пользовательских хуков позволяет вам перенести логику компонентов в функции, которые можно повторно использовать.
Пользовательские хуки — это скорее соглашение, соответствующее дизайну хуков, нежели чем возможность самого React.
Пользовательский хук — это JavaScript-функция, имя которой начинается с «use», и которая может вызывать другие хуки. 
* возможность повторного использования
* чистый код
* поддерживаемость
Пример: на сайте используется много модальных окон, и мы хотим их закрывать на esc и подтвержать на enter

### useCallback vs useMemo

> разница в том, что useCallback возвращает мемоизированный обратный вызов, а useMemo возвращает мемоизированное значение, результат вызова этой функции.

### Live cycle 
#### Монтирование
1. constructor()
2. static getDerivedStateFromProps(props, state) => объект для обновления состояния или null, чтобы ничего не обновлять
3. UNSAFE_componentWillMount()
4. render()
5. componentDidMount()
#### Обновление
1. static getDerivedStateFromProps(props, state)
2. shouldComponentUpdate(nextProps, nextState) => true or false 
3. render()
4. getSnapshotBeforeUpdate(prevProps, prevState)
5. componentDidUpdate(prevProps, prevState, snapshot)
#### Размонтирование
1. componentWillUnmount()

### Теория
-  Начинается все с монтирования, а продолжается обновлением. То есть компонент обновляется постоянно и происходит это до тех пор, пока он не перейдет на этап размонтирования, где удалится из виртуального DOM.

-  `shouldComponentUpdate(nextProps, nextState)` -  вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод не вызывается при первом рендере или когда используется forceUpdate().

-  `getSnapshotBeforeUpdate(prevProps, prevState):` вызывается непосредственно перед обновлением компонента. Он позволяет компоненту получить информацию из DOM перед возможным обновлением. Возвращает в качестве значения какое-то значение (или null), которое передается в качестве третьего параметра в метод componentDidUpdate()

- `useEffect` представляет собой совокупность методов componentDidMount, componentDidUpdate, и componentWillUnmount

- `getDerivedStateFromProps` вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять. Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.

- `getDerivedStateFromProps (hook)` - просто в теле компонента делаем условие, где проверяем пропсы, если разные, то обновляем state, что приведет к перерендованию

- `getSnapshotBeforeUpdate => useGetSnapshotBeforeUpdate (custom hook)`

- `UNSAFE_componentWillMount()` вызывается непосредственно перед монтированием. Он вызывается перед render(), поэтому синхронный вызов setState() в этом методе не вызовет дополнительную отрисовку. Как правило, мы рекомендуем использовать constructor() вместо этого для инициализации состояния.

- `UNSAFE_componentWillReceiveProps()` вызывается до того, как смонтированный компонент получит новые свойства. Если вам нужно обновить состояние в ответ на изменения свойства (например, для его сброса), вы можете сравнить this.props и nextProps и выполнить переходы состояния с помощью this.setState() в этом методе.

- Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами. React обновляет пропсы базового экземпляра компонента для соответствия новому элементу и вызывает UNSAFE_componentWillReceiveProps(), UNSAFE_componentWillUpdate и componentDidUpdate() на базовом экземпляре.

- `UNSAFE_componentWillUpdate()` вызывается непосредственно перед отрисовкой при получении новых свойств или состояния. Используйте это как возможность выполнить подготовку до того, как произойдет обновление. Этот метод не вызывается при первоначальной отрисовке.

> До 16.4 версии старый жизненный цикл. После - новый

### React Api Top Level
- `const Component = React.createFactory(type: span, div, MyComponent)` - Возвращает функцию, которая создаёт элементы React заданного типа
- `Component(props) `

- `React.Fragment` 

- `React.Component` - базовый класс для React-компонентов. Единственный обязательный метод это render(). 
Предоставляет методы ЖЦ, setState, forceUpdate, свойства displayName, forceUpdate, свойства экземпляра props, state

- React.createRef - создаёт реф, который можно прикрепить к React-элементам через атрибут ref. 

- PureComponent предполагает неглубокую проверку, изменения его props и state могут остаться проигнорированными 16.05
PureComponent будет всегда заново отрисовывать компоненты, если будет получать ссылки на разные объекты
Используя extend React.PureComponent, можно не добавлять метод жизненных циклов shouldComponentUpdate к компонентам: отслеживание изменений происходит само собой.
Но не стоит применять чистые компоненты повсеместно. Нужно понимать, что на сравнение props тоже нужны временные ресурсы
В функциональных можно использовать HOC

- Если ваш компонент всегда рендерит одно и то же при неменяющихся пропсах, вы можете обернуть его в вызов React.memo для повышения производительности в некоторых случаях, мемоизируя тем самым результат
Так же можно передать свою функцию для сравнения вторым параметром
`React.memo()`— Принцип ее работы схож с принципом работы React.PureComponent: помощь в управлении перерисовкой компонентов-функций.

- `React.isValidElement(object)` - Проверяет, что объект является элементом React. Возвращает true или false.

- `React.Children` предоставляет функции для работы с this.props.children.
map, foreach, count, toArray
Если children — это Fragment, он будет рассматриваться как целый потомок, а элементы внутри не будут пройдены.. 
React.Children.map(children, (x) => {  } )

### Оптимизация производительности
- Лучше не создавать функции и объекты во время рендеринга
- React.PureComponent
Сокращайте количество обновлений компонентов 
- React.memo
- Применяйте виртуализацию для больших списков 
Виртуализация — помогает создать иллюзию присутствия на странице очень большого (бесконечного) количества элементов, а фактически содержит только то количество, которое необходимо для их отображения в видимой области
Когда нужна виртуализация? Когда вам нужно отображать массивные списки. К примеру, отобразить на странице миллион элементов
- Используйте иммутабельность, а не сравнивать объекты по свойствам
- Не выполняйте тяжелые расчеты дважды без необходимости. Используйте shouldComponentUpdate или простое if условие в getDerivedStateFromProps, componentDidUpdate, сравнив старые и новые props. Также поможет мемоизация
- Для решения простых задач используйте нативный Api (а не писать методы самому или подключать библиотеки)
- Используйте продакшен сборку
- ленивая загрузка приложений (React lazy)
- настроить бандлы
- в пэкадже джейсон - правильное размещение зависимостей 
- настройка webpack

### Profiler 
Profiler измеряет то, как часто рендерится React-приложение и какова «стоимость» этого. Его задача — помочь найти медленные части приложения, которые можно оптимизировать (например, через мемоизацию).
Profiler может быть добавлен в любую часть React-дерева для измерения стоимости рендеринга этой части. Он принимает два пропа: id (string) и колбэк onRender (function), который React вызывает каждый раз, когда компонент внутри дерева «фиксирует» обновление.

