## --- Вопросы ---
<details><summary>1. Почему не стоит возвращать локальные для функции переменные по адресу или ссылке?</summary>
<p>

  Локальные переменные уничтожаются после выхода из функции. Если вы пытаетесь вернуть ссылку или указатель на такую переменную, то:
    - Ссылка или указатель будут указывать на память, которая больше не используется функцией.
    - Дальнейшая попытка доступа к этой памяти приводит к неопределённому поведению, так как данные могли быть уже перезаписаны.
    Как решение можно в функции создать static переменную и вернуть её по ссылке.

</p></details>

<details><summary>2. Что значит ключевое слово inline?</summary>
<p>

  ```
inline int square(int x) {
    return x * x;
}

int main() {
    int result = square(5); // Компилятор может заменить это на: int result = 5 * 5;
    return 0;
}
```
1. Замена вызова функции её кодом
2. Снижение накладных расходов
3. Использовать в определении небольших функций в заголовочных файлах

</p></details>

<details><summary>3. Что такое перегрузка функций?</summary>
<p>

  Функции с одним и тем же именем, но разным набором параметров (либо количество, либо тип). Функции, которые принимают параметры по ссылке или const (но не для ссылок и указателей) не различаются при перегрузке

</p></details>

<details><summary>4. Что такое куча и стек вызовов?</summary>
<p>

  "Куча" (heap) и "стек вызовов" `(call stack)` - это две разные области памяти. Стек вызовов используется для хранения информации о функциях, которые в данный момент вызываются в вашей программе. Куча используется для динамического выделения памяти во время выполнения программы. Это место, где вы можете создавать объекты и структуры данных переменного размера, и они остаются в памяти до явного освобождения.

</p></details>

<details><summary>5. Какие итераторы бывают?</summary><p>
  Константные (const_iterator) - такой итератор позволяет считывать элементы, но не изменять их. 
  Реверсивные (reverse_iterator) - Реверсивные итераторы позволяют перебирать элементы контейнера в обратном направлении.
</p></details>


<details><summary>6. Как в произвольное место в векторе вставить число?</summary>
<p>

  `vec.insert(vec.begin() + 2, 10);` // вставляем 10 на позицию 2

</p></details>

<details><summary>7. Назовите все контейнеры STL?</summary>
<p>

  `vector, list, deque, array, forward_list, set, map, multiset, multimap, unordered_set, unordered_map, unordered_multiset, unordered_multimap, stack, queue, priority_queue`

</p></details>

<details><summary>8. Чем работа list отличается от vector?</summary>
<p>

  Vector каждый раз пересоздается в отличии от list. У list нет прямого доступа к данным, только перебирать.

</p></details>

<details><summary>9. Назовите общие методы контейнеров STL?</summary>
<p>

`container<type> a(b)` Создаёт новый экземпляр контейнера типа `container` на основе уже существующего контейнера b.
`a.begin()` Возвращает итератор, указывающий на первый элемент контейнера a.
`a.end()` Возвращает итератор, указывающий на элемент, следующий за последним в контейнере a.
`a.size()` Возвращает размер контейнера a, то есть, количество элементов находящихся в нём.
`a.max_size()` Возвращает максимальный размер, который может иметь контейнер a.
`a.empty()` Определяет, пуст ли контейнер a. Эквивалентно `a.size() == 0`.
`a.swap(b)` Обменивает поэлементно содержимое контейнеров `a` и `b`. Эквивалентно `swap(a,b)`.

</p></details>

<details><summary>10. Чем отличается префисный инкремент от постфиксного?</summary>
<p>

  При префиксном инкременте сразу возвращается увеличенный элемент, а при постфиксном создаётся промежуточный элемент, который сначала возвращается, а потом увеличивается

</p></details>

<details><summary>11. Чем отличается NULL от nullptr?</summary>
<p>

  `null` это просто макрос для 0, поэтому может возникнуть проблема для проверки на `int`

</p></details>

<details><summary>12. Что такое массив указателей?</summary>
<p>

  массив указателей это тот же двухменый массив: `int **arr = new int* [rows]`

</p></details>

<details><summary>13. Что такое указатель? Ссылка?</summary>
<p>

  ---

</p></details>

<details><summary>14. Как создать и очистить двухмерный массив?</summary>
<p>

  ---

</p></details>

<details><summary>15. Как реализовать добавление и удаление в динамической массиве?</summary>
<p>

  Добавление. Сначала создаём новый массив на + 1 элемент, копируем из старого массива в новый, удаляем старый массив, присваиваем ссылку нового массива старому, увеличиваем `size`. Массив передавать `*&arr, &size`

</p></details>

<details><summary>16. Как узнать код символа и сам символ?</summary>
<p>

  ---

</p></details>

<details><summary>17. Назовите методы c-style строк?</summary>
<p>

  ---

</p></details>

<details><summary>18. Что такое оператор goto?</summary>
<p>

  ``Оператор goto`` — это оператор управления потоком выполнения программ, который заставляет центральный процессор выполнить переход из одного участка кода в другой (осуществить прыжок)

</p></details>

<details><summary>19. Почему цикл foreach не работает с динамическим массивами?</summary>
<p>

  Для итерации по массиву, цикл `foreach` должен знать длину массива. Поскольку массивы, которые распадаются в указатель (динамические массивы), не знают своей длины, то циклы `foreach` с ними работать не могут!

</p></details>

<details><summary>20. Что такое int argc и char *argv[] в функции main?</summary>
<p>

  Аргументы командной строки. argc - количество аргументов, переданных в программу, argv - место, где хранятся фактические значения аргументов (массив c-style строк)

</p></details>

<details><summary>21. Как объединить строки в стиле C?</summary>
<p>

  Для объединения в стиле с использовать strcat

</p></details>

<details><summary>22. Что такое указатель на функцию?</summary>
<p>

  Указатель на функцию это такая переменная, которой мы можем присвоить ссылку на функцию

</p></details>

<details><summary>23. Чем опасно использовать директиву препроцессора define?</summary>
<p>

  `define` позволяет определить некоторую константу, например, `#define begin {`, которая будет заменять все `begin` на `{`. Но `begin` может существоаать в `c++`, поэтому вызов нативного `begin` вызовет ошибку

</p></details>

<details><summary>24. Когда наиболее лучше всего использовать директивы ifdef и endif?</summary>
<p>

  Такие директивы лучше всего использовать тогда, когда у на есть какая то отладочная информация (`cout` что то например), и мы не хотим их удалить или комментить. Мы можем их обернуть в дерективы и управлять, опять выводить или нет. Также есть ещё `#else`

</p></details>

<details><summary>25. Что такое обработчики cath all?</summary>
<p>

  `Catch all` перехватываюет все исключения. `catch (...) { }`

</p></details>

<details><summary>26. Как объявить лямду? Что такое и как сделать захват переменных? Что такео универсальные лямды? Как передать лямду?</summary>
<p>

  ---

</p></details>

<details><summary>27. Как происходит работа с потоками на примере функции подсчета факториала 3х чисел? (A)</summary>
<p>

  (A) Объявляем ``vector<thread> ts.`` Определяем функцию для потока: ``ts.emplace_back([ ] () { fac(num)) }`` - добавляем лямду в вектор потоков. Делаем ``ts[i].join()``

</p></details>

<details><summary>28. Зачем нужен виртуальный деструктор?</summary>
<p>

  Чтобы избежать возможной утечки ресурсов или другого неконтролируемого поведения объекта, в логику работы которого включен вызов деструктора.

</p></details>

<details><summary>29. Как защитить объект от копирования?</summary>
<p>

  Сделать private конструктор копирования и оператор =.

</p></details>

<details><summary>30. В чем разница между struct и class?</summary>
<p>

  Практически ни в чем. В struct модификаторы доступа по умолчанию public, в class private. Также отличается и наследование по умолчанию, у struct — public, у class — private.

</p></details>

<details><summary>32. Сколько в памяти занимает произвольная структура?</summary>
<p>

  `sizeof` всех членов + остаток для выравнивания (по умолчанию выравнивание 4 байта) + `sizeof` указателя на `vtable` (если есть виртуальные функции) + указатели на классы предков, от которых было сделано виртуальное наследование (размер указателя * количество классов).

</p></details>

<details><summary>33. В чем отличие vector от deque?</summary>
<p>

  у `deque` (двухстороннюю очередь) есть методы `push_front и pop_front`. Но основное отличие в организации памяти, у vector она как у обычного Си-массива, т.е. последовательный и непрерывный набор байт, а у `deque` это фрагменты с разрывами.

</p></details>

<details><summary>34. Для чего нужен аллокатор?</summary>
<p>

  Аллокатор это шаблонный класс, который отвечает за выделение памяти и создание объектов. По умолчанию все контейнера используют `std::allocator<T>`.

</p></details>

<details><summary>35. В чём суть множественного наследования? Какие проблемы могут возникнуть при его использовании? Как их преодолеть?</summary>
<p>

  Множественное наследование – мощный способ связи классов в с++. С помощью множественного наследования класс может иметь сразу несколько базовых классов, объединяя в себе их свойства. Проблемы, собственно говоря, возникают, когда имеет место такая ситуация:
Пусть класс A – базовый, далее классы B и С наследуют A, к классу D применено множественное наследование - для него базовыми являются одновременно B и C. Программа видит эту структуры таким образом (code). Избежать данной проблемы поможет использование ключевого слова virtual, которое превращает класс A в виртуальный класс, так сказать «класс – шаблон».
```
  A(1)    A(2)
    |      |
    B      C
     \    /
        D
```

</p></details>

<details><summary>36. В чем основное различие между деструктором и оператором delete?</summary>
<p>

  Оператор `delete` освобождает область памяти зарезервированную ранее с помощью оператора new. При этом для объектов автоматически будет вызван деструктор. Деструктор содержит код, который необходимо выполнить до освобождения памяти.

</p></details>

<details><summary>37. В чем разница между массивом и списком?</summary>
<p>

  Массив – это набор однородных элементов, а **список** – разнородных.
Распределение памяти массива всегда статическое и непрерывное, а в списке все это динамическое и рандомное.

</p></details>

<details><summary>38. Что делает функция Friend в C ++?</summary>
<p>

  Когда функция или класс объявляются как другие (с использованием **friend**), это означает, что они имеют доступ к приватным и защищенным членам другого класса, как если бы они были методами этого класса. У класса есть private член. Мы вне класса объеявляем функцию, а в классе ее определяем как friend void func(MyClass const MyClass& obj). Теперь данная функция может использовать private члены.

</p></details>

<details><summary>39. Что такое виртуальные функции?</summary>
<p>

**Виртуальные функции** - это ключевой механизм в объектно-ориентированном программировании (ООП) в C++, который позволяет реализовать полиморфизм.  Она может иметь реализацию по умолчанию или быть чисто виртуальной (абстрактной) функцией без реализации. Виртуальную функцию можно переопределить в производных (дочерних) классах. Это означает, что каждый дочерний класс может предоставить свою собственную реализацию этой функции.

</p></details>

<details><summary>40. В чем разница между мьютексом и семафором?</summary>
<p>

  **Мьютекс (mutex) и семафор (semaphore)** - это два разных механизма синхронизации в многозадачных и многопоточных программах. Оба они могут использоваться для обеспечения безопасного доступа к общим ресурсам. Мьютекс - это средство синхронизации, которое позволяет только одному потоку или процессу одновременно получить доступ к общему ресурсу. Семафор - это средство синхронизации, которое позволяет ограничивать количество потоков, имеющих доступ к общему ресурсу.

</p></details>

<details><summary>41. Как срабатывают конструкторы и деструкторы при наследовании в с++</summary>
<p>

    ```
    A -> B -> C
    C *c = new C();
    delete c;
    // A, B, C, ~C, ~B, ~A
    ```

</p></details>

<details><summary>42. Что такое string::npos?</summary>
<p>

  Это константа в C++, которая используется для обозначения "не найденного" значения при работе со строками. Если равен npos, то не найдено.

</p></details>

<details><summary>43. Для чего нужен спецификатор final?</summary>
<p>

  С помощью спецификатора `final` мы можем запретить наследование: `class Person final {};`

</p></details>
